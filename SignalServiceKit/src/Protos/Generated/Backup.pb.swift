//
// Copyright 2023 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Backup.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2014 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only

/// iOS - since we use a modern proto-compiler, we must specify
/// the legacy proto format.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct BackupProtos_BackupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var version: UInt64 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  /// @required
  var backupTimeMs: UInt64 {
    get {return _backupTimeMs ?? 0}
    set {_backupTimeMs = newValue}
  }
  /// Returns true if `backupTimeMs` has been explicitly set.
  var hasBackupTimeMs: Bool {return self._backupTimeMs != nil}
  /// Clears the value of `backupTimeMs`. Subsequent reads from it will return its default value.
  mutating func clearBackupTimeMs() {self._backupTimeMs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: UInt64? = nil
  fileprivate var _backupTimeMs: UInt64? = nil
}

struct BackupProtos_Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof item {
  var account: BackupProtos_AccountData {
    get {return _storage._account ?? BackupProtos_AccountData()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  var recipient: BackupProtos_Recipient {
    get {return _storage._recipient ?? BackupProtos_Recipient()}
    set {_uniqueStorage()._recipient = newValue}
  }
  /// Returns true if `recipient` has been explicitly set.
  var hasRecipient: Bool {return _storage._recipient != nil}
  /// Clears the value of `recipient`. Subsequent reads from it will return its default value.
  mutating func clearRecipient() {_uniqueStorage()._recipient = nil}

  var chat: BackupProtos_Chat {
    get {return _storage._chat ?? BackupProtos_Chat()}
    set {_uniqueStorage()._chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  var hasChat: Bool {return _storage._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  mutating func clearChat() {_uniqueStorage()._chat = nil}

  var chatItem: BackupProtos_ChatItem {
    get {return _storage._chatItem ?? BackupProtos_ChatItem()}
    set {_uniqueStorage()._chatItem = newValue}
  }
  /// Returns true if `chatItem` has been explicitly set.
  var hasChatItem: Bool {return _storage._chatItem != nil}
  /// Clears the value of `chatItem`. Subsequent reads from it will return its default value.
  mutating func clearChatItem() {_uniqueStorage()._chatItem = nil}

  var call: BackupProtos_Call {
    get {return _storage._call ?? BackupProtos_Call()}
    set {_uniqueStorage()._call = newValue}
  }
  /// Returns true if `call` has been explicitly set.
  var hasCall: Bool {return _storage._call != nil}
  /// Clears the value of `call`. Subsequent reads from it will return its default value.
  mutating func clearCall() {_uniqueStorage()._call = nil}

  /// }
  var stickerPack: BackupProtos_StickerPack {
    get {return _storage._stickerPack ?? BackupProtos_StickerPack()}
    set {_uniqueStorage()._stickerPack = newValue}
  }
  /// Returns true if `stickerPack` has been explicitly set.
  var hasStickerPack: Bool {return _storage._stickerPack != nil}
  /// Clears the value of `stickerPack`. Subsequent reads from it will return its default value.
  mutating func clearStickerPack() {_uniqueStorage()._stickerPack = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_AccountData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var profileKey: Data {
    get {return _profileKey ?? Data()}
    set {_profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return self._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {self._profileKey = nil}

  var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {self._username = nil}

  /// @required
  var usernameLink: BackupProtos_AccountData.UsernameLink {
    get {return _usernameLink ?? BackupProtos_AccountData.UsernameLink()}
    set {_usernameLink = newValue}
  }
  /// Returns true if `usernameLink` has been explicitly set.
  var hasUsernameLink: Bool {return self._usernameLink != nil}
  /// Clears the value of `usernameLink`. Subsequent reads from it will return its default value.
  mutating func clearUsernameLink() {self._usernameLink = nil}

  /// @required
  var givenName: String {
    get {return _givenName ?? String()}
    set {_givenName = newValue}
  }
  /// Returns true if `givenName` has been explicitly set.
  var hasGivenName: Bool {return self._givenName != nil}
  /// Clears the value of `givenName`. Subsequent reads from it will return its default value.
  mutating func clearGivenName() {self._givenName = nil}

  /// @required
  var familyName: String {
    get {return _familyName ?? String()}
    set {_familyName = newValue}
  }
  /// Returns true if `familyName` has been explicitly set.
  var hasFamilyName: Bool {return self._familyName != nil}
  /// Clears the value of `familyName`. Subsequent reads from it will return its default value.
  mutating func clearFamilyName() {self._familyName = nil}

  /// @required
  var avatarPath: String {
    get {return _avatarPath ?? String()}
    set {_avatarPath = newValue}
  }
  /// Returns true if `avatarPath` has been explicitly set.
  var hasAvatarPath: Bool {return self._avatarPath != nil}
  /// Clears the value of `avatarPath`. Subsequent reads from it will return its default value.
  mutating func clearAvatarPath() {self._avatarPath = nil}

  /// @required
  var subscriberID: Data {
    get {return _subscriberID ?? Data()}
    set {_subscriberID = newValue}
  }
  /// Returns true if `subscriberID` has been explicitly set.
  var hasSubscriberID: Bool {return self._subscriberID != nil}
  /// Clears the value of `subscriberID`. Subsequent reads from it will return its default value.
  mutating func clearSubscriberID() {self._subscriberID = nil}

  /// @required
  var subscriberCurrencyCode: String {
    get {return _subscriberCurrencyCode ?? String()}
    set {_subscriberCurrencyCode = newValue}
  }
  /// Returns true if `subscriberCurrencyCode` has been explicitly set.
  var hasSubscriberCurrencyCode: Bool {return self._subscriberCurrencyCode != nil}
  /// Clears the value of `subscriberCurrencyCode`. Subsequent reads from it will return its default value.
  mutating func clearSubscriberCurrencyCode() {self._subscriberCurrencyCode = nil}

  /// @required
  var subscriptionManuallyCancelled: Bool {
    get {return _subscriptionManuallyCancelled ?? false}
    set {_subscriptionManuallyCancelled = newValue}
  }
  /// Returns true if `subscriptionManuallyCancelled` has been explicitly set.
  var hasSubscriptionManuallyCancelled: Bool {return self._subscriptionManuallyCancelled != nil}
  /// Clears the value of `subscriptionManuallyCancelled`. Subsequent reads from it will return its default value.
  mutating func clearSubscriptionManuallyCancelled() {self._subscriptionManuallyCancelled = nil}

  /// @required
  var accountSettings: BackupProtos_AccountData.AccountSettings {
    get {return _accountSettings ?? BackupProtos_AccountData.AccountSettings()}
    set {_accountSettings = newValue}
  }
  /// Returns true if `accountSettings` has been explicitly set.
  var hasAccountSettings: Bool {return self._accountSettings != nil}
  /// Clears the value of `accountSettings`. Subsequent reads from it will return its default value.
  mutating func clearAccountSettings() {self._accountSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PhoneNumberSharingMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case everybody // = 1
    case nobody // = 2

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .everybody
      case 2: self = .nobody
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .everybody: return 1
      case .nobody: return 2
      }
    }

  }

  struct UsernameLink {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var entropy: Data {
      get {return _entropy ?? Data()}
      set {_entropy = newValue}
    }
    /// Returns true if `entropy` has been explicitly set.
    var hasEntropy: Bool {return self._entropy != nil}
    /// Clears the value of `entropy`. Subsequent reads from it will return its default value.
    mutating func clearEntropy() {self._entropy = nil}

    /// @required
    var serverID: Data {
      get {return _serverID ?? Data()}
      set {_serverID = newValue}
    }
    /// Returns true if `serverID` has been explicitly set.
    var hasServerID: Bool {return self._serverID != nil}
    /// Clears the value of `serverID`. Subsequent reads from it will return its default value.
    mutating func clearServerID() {self._serverID = nil}

    var color: BackupProtos_AccountData.UsernameLink.Color {
      get {return _color ?? .unknown}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Color: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case blue // = 1
      case white // = 2
      case grey // = 3
      case olive // = 4
      case green // = 5
      case orange // = 6
      case pink // = 7
      case purple // = 8

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .blue
        case 2: self = .white
        case 3: self = .grey
        case 4: self = .olive
        case 5: self = .green
        case 6: self = .orange
        case 7: self = .pink
        case 8: self = .purple
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .blue: return 1
        case .white: return 2
        case .grey: return 3
        case .olive: return 4
        case .green: return 5
        case .orange: return 6
        case .pink: return 7
        case .purple: return 8
        }
      }

    }

    init() {}

    fileprivate var _entropy: Data? = nil
    fileprivate var _serverID: Data? = nil
    fileprivate var _color: BackupProtos_AccountData.UsernameLink.Color? = nil
  }

  struct AccountSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var readReceipts: Bool {
      get {return _storage._readReceipts ?? false}
      set {_uniqueStorage()._readReceipts = newValue}
    }
    /// Returns true if `readReceipts` has been explicitly set.
    var hasReadReceipts: Bool {return _storage._readReceipts != nil}
    /// Clears the value of `readReceipts`. Subsequent reads from it will return its default value.
    mutating func clearReadReceipts() {_uniqueStorage()._readReceipts = nil}

    /// @required
    var sealedSenderIndicators: Bool {
      get {return _storage._sealedSenderIndicators ?? false}
      set {_uniqueStorage()._sealedSenderIndicators = newValue}
    }
    /// Returns true if `sealedSenderIndicators` has been explicitly set.
    var hasSealedSenderIndicators: Bool {return _storage._sealedSenderIndicators != nil}
    /// Clears the value of `sealedSenderIndicators`. Subsequent reads from it will return its default value.
    mutating func clearSealedSenderIndicators() {_uniqueStorage()._sealedSenderIndicators = nil}

    /// @required
    var typingIndicators: Bool {
      get {return _storage._typingIndicators ?? false}
      set {_uniqueStorage()._typingIndicators = newValue}
    }
    /// Returns true if `typingIndicators` has been explicitly set.
    var hasTypingIndicators: Bool {return _storage._typingIndicators != nil}
    /// Clears the value of `typingIndicators`. Subsequent reads from it will return its default value.
    mutating func clearTypingIndicators() {_uniqueStorage()._typingIndicators = nil}

    /// @required
    var noteToSelfMarkedUnread: Bool {
      get {return _storage._noteToSelfMarkedUnread ?? false}
      set {_uniqueStorage()._noteToSelfMarkedUnread = newValue}
    }
    /// Returns true if `noteToSelfMarkedUnread` has been explicitly set.
    var hasNoteToSelfMarkedUnread: Bool {return _storage._noteToSelfMarkedUnread != nil}
    /// Clears the value of `noteToSelfMarkedUnread`. Subsequent reads from it will return its default value.
    mutating func clearNoteToSelfMarkedUnread() {_uniqueStorage()._noteToSelfMarkedUnread = nil}

    /// @required
    var linkPreviews: Bool {
      get {return _storage._linkPreviews ?? false}
      set {_uniqueStorage()._linkPreviews = newValue}
    }
    /// Returns true if `linkPreviews` has been explicitly set.
    var hasLinkPreviews: Bool {return _storage._linkPreviews != nil}
    /// Clears the value of `linkPreviews`. Subsequent reads from it will return its default value.
    mutating func clearLinkPreviews() {_uniqueStorage()._linkPreviews = nil}

    /// @required
    var unlistedPhoneeumber: Bool {
      get {return _storage._unlistedPhoneeumber ?? false}
      set {_uniqueStorage()._unlistedPhoneeumber = newValue}
    }
    /// Returns true if `unlistedPhoneeumber` has been explicitly set.
    var hasUnlistedPhoneeumber: Bool {return _storage._unlistedPhoneeumber != nil}
    /// Clears the value of `unlistedPhoneeumber`. Subsequent reads from it will return its default value.
    mutating func clearUnlistedPhoneeumber() {_uniqueStorage()._unlistedPhoneeumber = nil}

    /// @required
    var preferContactAvatars: Bool {
      get {return _storage._preferContactAvatars ?? false}
      set {_uniqueStorage()._preferContactAvatars = newValue}
    }
    /// Returns true if `preferContactAvatars` has been explicitly set.
    var hasPreferContactAvatars: Bool {return _storage._preferContactAvatars != nil}
    /// Clears the value of `preferContactAvatars`. Subsequent reads from it will return its default value.
    mutating func clearPreferContactAvatars() {_uniqueStorage()._preferContactAvatars = nil}

    /// @required
    var universalExpireTimer: UInt32 {
      get {return _storage._universalExpireTimer ?? 0}
      set {_uniqueStorage()._universalExpireTimer = newValue}
    }
    /// Returns true if `universalExpireTimer` has been explicitly set.
    var hasUniversalExpireTimer: Bool {return _storage._universalExpireTimer != nil}
    /// Clears the value of `universalExpireTimer`. Subsequent reads from it will return its default value.
    mutating func clearUniversalExpireTimer() {_uniqueStorage()._universalExpireTimer = nil}

    var preferredReactionEmoji: [String] {
      get {return _storage._preferredReactionEmoji}
      set {_uniqueStorage()._preferredReactionEmoji = newValue}
    }

    /// @required
    var displayBadgesOnProfile: Bool {
      get {return _storage._displayBadgesOnProfile ?? false}
      set {_uniqueStorage()._displayBadgesOnProfile = newValue}
    }
    /// Returns true if `displayBadgesOnProfile` has been explicitly set.
    var hasDisplayBadgesOnProfile: Bool {return _storage._displayBadgesOnProfile != nil}
    /// Clears the value of `displayBadgesOnProfile`. Subsequent reads from it will return its default value.
    mutating func clearDisplayBadgesOnProfile() {_uniqueStorage()._displayBadgesOnProfile = nil}

    /// @required
    var keepMutedChatsArchived: Bool {
      get {return _storage._keepMutedChatsArchived ?? false}
      set {_uniqueStorage()._keepMutedChatsArchived = newValue}
    }
    /// Returns true if `keepMutedChatsArchived` has been explicitly set.
    var hasKeepMutedChatsArchived: Bool {return _storage._keepMutedChatsArchived != nil}
    /// Clears the value of `keepMutedChatsArchived`. Subsequent reads from it will return its default value.
    mutating func clearKeepMutedChatsArchived() {_uniqueStorage()._keepMutedChatsArchived = nil}

    /// @required
    var myStoriesPrivacyHasBeenSet: Bool {
      get {return _storage._myStoriesPrivacyHasBeenSet ?? false}
      set {_uniqueStorage()._myStoriesPrivacyHasBeenSet = newValue}
    }
    /// Returns true if `myStoriesPrivacyHasBeenSet` has been explicitly set.
    var hasMyStoriesPrivacyHasBeenSet: Bool {return _storage._myStoriesPrivacyHasBeenSet != nil}
    /// Clears the value of `myStoriesPrivacyHasBeenSet`. Subsequent reads from it will return its default value.
    mutating func clearMyStoriesPrivacyHasBeenSet() {_uniqueStorage()._myStoriesPrivacyHasBeenSet = nil}

    /// @required
    var onboardingStoryHasBeenViewed: Bool {
      get {return _storage._onboardingStoryHasBeenViewed ?? false}
      set {_uniqueStorage()._onboardingStoryHasBeenViewed = newValue}
    }
    /// Returns true if `onboardingStoryHasBeenViewed` has been explicitly set.
    var hasOnboardingStoryHasBeenViewed: Bool {return _storage._onboardingStoryHasBeenViewed != nil}
    /// Clears the value of `onboardingStoryHasBeenViewed`. Subsequent reads from it will return its default value.
    mutating func clearOnboardingStoryHasBeenViewed() {_uniqueStorage()._onboardingStoryHasBeenViewed = nil}

    /// @required
    var storiesDisabled: Bool {
      get {return _storage._storiesDisabled ?? false}
      set {_uniqueStorage()._storiesDisabled = newValue}
    }
    /// Returns true if `storiesDisabled` has been explicitly set.
    var hasStoriesDisabled: Bool {return _storage._storiesDisabled != nil}
    /// Clears the value of `storiesDisabled`. Subsequent reads from it will return its default value.
    mutating func clearStoriesDisabled() {_uniqueStorage()._storiesDisabled = nil}

    var storyViewReceiptsEnabled: Bool {
      get {return _storage._storyViewReceiptsEnabled ?? false}
      set {_uniqueStorage()._storyViewReceiptsEnabled = newValue}
    }
    /// Returns true if `storyViewReceiptsEnabled` has been explicitly set.
    var hasStoryViewReceiptsEnabled: Bool {return _storage._storyViewReceiptsEnabled != nil}
    /// Clears the value of `storyViewReceiptsEnabled`. Subsequent reads from it will return its default value.
    mutating func clearStoryViewReceiptsEnabled() {_uniqueStorage()._storyViewReceiptsEnabled = nil}

    /// @required
    var groupStoryEducationSheetHasBeenSeen: Bool {
      get {return _storage._groupStoryEducationSheetHasBeenSeen ?? false}
      set {_uniqueStorage()._groupStoryEducationSheetHasBeenSeen = newValue}
    }
    /// Returns true if `groupStoryEducationSheetHasBeenSeen` has been explicitly set.
    var hasGroupStoryEducationSheetHasBeenSeen: Bool {return _storage._groupStoryEducationSheetHasBeenSeen != nil}
    /// Clears the value of `groupStoryEducationSheetHasBeenSeen`. Subsequent reads from it will return its default value.
    mutating func clearGroupStoryEducationSheetHasBeenSeen() {_uniqueStorage()._groupStoryEducationSheetHasBeenSeen = nil}

    /// @required
    var usernameOnboardingHasBeenCompleted: Bool {
      get {return _storage._usernameOnboardingHasBeenCompleted ?? false}
      set {_uniqueStorage()._usernameOnboardingHasBeenCompleted = newValue}
    }
    /// Returns true if `usernameOnboardingHasBeenCompleted` has been explicitly set.
    var hasUsernameOnboardingHasBeenCompleted: Bool {return _storage._usernameOnboardingHasBeenCompleted != nil}
    /// Clears the value of `usernameOnboardingHasBeenCompleted`. Subsequent reads from it will return its default value.
    mutating func clearUsernameOnboardingHasBeenCompleted() {_uniqueStorage()._usernameOnboardingHasBeenCompleted = nil}

    var phoneNumberSharingMode: BackupProtos_AccountData.PhoneNumberSharingMode {
      get {return _storage._phoneNumberSharingMode ?? .unknown}
      set {_uniqueStorage()._phoneNumberSharingMode = newValue}
    }
    /// Returns true if `phoneNumberSharingMode` has been explicitly set.
    var hasPhoneNumberSharingMode: Bool {return _storage._phoneNumberSharingMode != nil}
    /// Clears the value of `phoneNumberSharingMode`. Subsequent reads from it will return its default value.
    mutating func clearPhoneNumberSharingMode() {_uniqueStorage()._phoneNumberSharingMode = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _profileKey: Data? = nil
  fileprivate var _username: String? = nil
  fileprivate var _usernameLink: BackupProtos_AccountData.UsernameLink? = nil
  fileprivate var _givenName: String? = nil
  fileprivate var _familyName: String? = nil
  fileprivate var _avatarPath: String? = nil
  fileprivate var _subscriberID: Data? = nil
  fileprivate var _subscriberCurrencyCode: String? = nil
  fileprivate var _subscriptionManuallyCancelled: Bool? = nil
  fileprivate var _accountSettings: BackupProtos_AccountData.AccountSettings? = nil
}

#if swift(>=4.2)

extension BackupProtos_AccountData.PhoneNumberSharingMode: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_AccountData.UsernameLink.Color: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Recipient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: UInt64 {
    get {return _storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  /// oneof destination {
  var contact: BackupProtos_Contact {
    get {return _storage._contact ?? BackupProtos_Contact()}
    set {_uniqueStorage()._contact = newValue}
  }
  /// Returns true if `contact` has been explicitly set.
  var hasContact: Bool {return _storage._contact != nil}
  /// Clears the value of `contact`. Subsequent reads from it will return its default value.
  mutating func clearContact() {_uniqueStorage()._contact = nil}

  var group: BackupProtos_Group {
    get {return _storage._group ?? BackupProtos_Group()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {_uniqueStorage()._group = nil}

  var distributionList: BackupProtos_DistributionList {
    get {return _storage._distributionList ?? BackupProtos_DistributionList()}
    set {_uniqueStorage()._distributionList = newValue}
  }
  /// Returns true if `distributionList` has been explicitly set.
  var hasDistributionList: Bool {return _storage._distributionList != nil}
  /// Clears the value of `distributionList`. Subsequent reads from it will return its default value.
  mutating func clearDistributionList() {_uniqueStorage()._distributionList = nil}

  var selfRecipient: BackupProtos_SelfRecipient {
    get {return _storage._selfRecipient ?? BackupProtos_SelfRecipient()}
    set {_uniqueStorage()._selfRecipient = newValue}
  }
  /// Returns true if `selfRecipient` has been explicitly set.
  var hasSelfRecipient: Bool {return _storage._selfRecipient != nil}
  /// Clears the value of `selfRecipient`. Subsequent reads from it will return its default value.
  mutating func clearSelfRecipient() {_uniqueStorage()._selfRecipient = nil}

  /// }
  var releaseNotes: BackupProtos_ReleaseNotes {
    get {return _storage._releaseNotes ?? BackupProtos_ReleaseNotes()}
    set {_uniqueStorage()._releaseNotes = newValue}
  }
  /// Returns true if `releaseNotes` has been explicitly set.
  var hasReleaseNotes: Bool {return _storage._releaseNotes != nil}
  /// Clears the value of `releaseNotes`. Subsequent reads from it will return its default value.
  mutating func clearReleaseNotes() {_uniqueStorage()._releaseNotes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// should be 16 bytes
  var aci: Data {
    get {return _aci ?? Data()}
    set {_aci = newValue}
  }
  /// Returns true if `aci` has been explicitly set.
  var hasAci: Bool {return self._aci != nil}
  /// Clears the value of `aci`. Subsequent reads from it will return its default value.
  mutating func clearAci() {self._aci = nil}

  /// should be 16 bytes
  var pni: Data {
    get {return _pni ?? Data()}
    set {_pni = newValue}
  }
  /// Returns true if `pni` has been explicitly set.
  var hasPni: Bool {return self._pni != nil}
  /// Clears the value of `pni`. Subsequent reads from it will return its default value.
  mutating func clearPni() {self._pni = nil}

  var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {self._username = nil}

  var e164: UInt64 {
    get {return _e164 ?? 0}
    set {_e164 = newValue}
  }
  /// Returns true if `e164` has been explicitly set.
  var hasE164: Bool {return self._e164 != nil}
  /// Clears the value of `e164`. Subsequent reads from it will return its default value.
  mutating func clearE164() {self._e164 = nil}

  /// @required
  var blocked: Bool {
    get {return _blocked ?? false}
    set {_blocked = newValue}
  }
  /// Returns true if `blocked` has been explicitly set.
  var hasBlocked: Bool {return self._blocked != nil}
  /// Clears the value of `blocked`. Subsequent reads from it will return its default value.
  mutating func clearBlocked() {self._blocked = nil}

  /// @required
  var hidden: Bool {
    get {return _hidden ?? false}
    set {_hidden = newValue}
  }
  /// Returns true if `hidden` has been explicitly set.
  var hasHidden: Bool {return self._hidden != nil}
  /// Clears the value of `hidden`. Subsequent reads from it will return its default value.
  mutating func clearHidden() {self._hidden = nil}

  var registered: BackupProtos_Contact.Registered {
    get {return _registered ?? .unknown}
    set {_registered = newValue}
  }
  /// Returns true if `registered` has been explicitly set.
  var hasRegistered: Bool {return self._registered != nil}
  /// Clears the value of `registered`. Subsequent reads from it will return its default value.
  mutating func clearRegistered() {self._registered = nil}

  /// @required
  var unregisteredTimestamp: UInt64 {
    get {return _unregisteredTimestamp ?? 0}
    set {_unregisteredTimestamp = newValue}
  }
  /// Returns true if `unregisteredTimestamp` has been explicitly set.
  var hasUnregisteredTimestamp: Bool {return self._unregisteredTimestamp != nil}
  /// Clears the value of `unregisteredTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearUnregisteredTimestamp() {self._unregisteredTimestamp = nil}

  var profileKey: Data {
    get {return _profileKey ?? Data()}
    set {_profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return self._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {self._profileKey = nil}

  /// @required
  var profileSharing: Bool {
    get {return _profileSharing ?? false}
    set {_profileSharing = newValue}
  }
  /// Returns true if `profileSharing` has been explicitly set.
  var hasProfileSharing: Bool {return self._profileSharing != nil}
  /// Clears the value of `profileSharing`. Subsequent reads from it will return its default value.
  mutating func clearProfileSharing() {self._profileSharing = nil}

  var profileGivenName: String {
    get {return _profileGivenName ?? String()}
    set {_profileGivenName = newValue}
  }
  /// Returns true if `profileGivenName` has been explicitly set.
  var hasProfileGivenName: Bool {return self._profileGivenName != nil}
  /// Clears the value of `profileGivenName`. Subsequent reads from it will return its default value.
  mutating func clearProfileGivenName() {self._profileGivenName = nil}

  var profileFamilyName: String {
    get {return _profileFamilyName ?? String()}
    set {_profileFamilyName = newValue}
  }
  /// Returns true if `profileFamilyName` has been explicitly set.
  var hasProfileFamilyName: Bool {return self._profileFamilyName != nil}
  /// Clears the value of `profileFamilyName`. Subsequent reads from it will return its default value.
  mutating func clearProfileFamilyName() {self._profileFamilyName = nil}

  /// @required
  var hideStory: Bool {
    get {return _hideStory ?? false}
    set {_hideStory = newValue}
  }
  /// Returns true if `hideStory` has been explicitly set.
  var hasHideStory: Bool {return self._hideStory != nil}
  /// Clears the value of `hideStory`. Subsequent reads from it will return its default value.
  mutating func clearHideStory() {self._hideStory = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Registered: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case registered // = 1
    case notRegistered // = 2

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .registered
      case 2: self = .notRegistered
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .registered: return 1
      case .notRegistered: return 2
      }
    }

  }

  init() {}

  fileprivate var _aci: Data? = nil
  fileprivate var _pni: Data? = nil
  fileprivate var _username: String? = nil
  fileprivate var _e164: UInt64? = nil
  fileprivate var _blocked: Bool? = nil
  fileprivate var _hidden: Bool? = nil
  fileprivate var _registered: BackupProtos_Contact.Registered? = nil
  fileprivate var _unregisteredTimestamp: UInt64? = nil
  fileprivate var _profileKey: Data? = nil
  fileprivate var _profileSharing: Bool? = nil
  fileprivate var _profileGivenName: String? = nil
  fileprivate var _profileFamilyName: String? = nil
  fileprivate var _hideStory: Bool? = nil
}

#if swift(>=4.2)

extension BackupProtos_Contact.Registered: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var masterKey: Data {
    get {return _masterKey ?? Data()}
    set {_masterKey = newValue}
  }
  /// Returns true if `masterKey` has been explicitly set.
  var hasMasterKey: Bool {return self._masterKey != nil}
  /// Clears the value of `masterKey`. Subsequent reads from it will return its default value.
  mutating func clearMasterKey() {self._masterKey = nil}

  /// @required
  var whitelisted: Bool {
    get {return _whitelisted ?? false}
    set {_whitelisted = newValue}
  }
  /// Returns true if `whitelisted` has been explicitly set.
  var hasWhitelisted: Bool {return self._whitelisted != nil}
  /// Clears the value of `whitelisted`. Subsequent reads from it will return its default value.
  mutating func clearWhitelisted() {self._whitelisted = nil}

  /// @required
  var hideStory: Bool {
    get {return _hideStory ?? false}
    set {_hideStory = newValue}
  }
  /// Returns true if `hideStory` has been explicitly set.
  var hasHideStory: Bool {return self._hideStory != nil}
  /// Clears the value of `hideStory`. Subsequent reads from it will return its default value.
  mutating func clearHideStory() {self._hideStory = nil}

  var storySendMode: BackupProtos_Group.StorySendMode {
    get {return _storySendMode ?? .default}
    set {_storySendMode = newValue}
  }
  /// Returns true if `storySendMode` has been explicitly set.
  var hasStorySendMode: Bool {return self._storySendMode != nil}
  /// Clears the value of `storySendMode`. Subsequent reads from it will return its default value.
  mutating func clearStorySendMode() {self._storySendMode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StorySendMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case disabled // = 1
    case enabled // = 2

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .disabled
      case 2: self = .enabled
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .disabled: return 1
      case .enabled: return 2
      }
    }

  }

  init() {}

  fileprivate var _masterKey: Data? = nil
  fileprivate var _whitelisted: Bool? = nil
  fileprivate var _hideStory: Bool? = nil
  fileprivate var _storySendMode: BackupProtos_Group.StorySendMode? = nil
}

#if swift(>=4.2)

extension BackupProtos_Group.StorySendMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_SelfRecipient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_ReleaseNotes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_Chat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: UInt64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// @required
  var recipientID: UInt64 {
    get {return _recipientID ?? 0}
    set {_recipientID = newValue}
  }
  /// Returns true if `recipientID` has been explicitly set.
  var hasRecipientID: Bool {return self._recipientID != nil}
  /// Clears the value of `recipientID`. Subsequent reads from it will return its default value.
  mutating func clearRecipientID() {self._recipientID = nil}

  /// @required
  var archived: Bool {
    get {return _archived ?? false}
    set {_archived = newValue}
  }
  /// Returns true if `archived` has been explicitly set.
  var hasArchived: Bool {return self._archived != nil}
  /// Clears the value of `archived`. Subsequent reads from it will return its default value.
  mutating func clearArchived() {self._archived = nil}

  /// @required
  var pinnedOrder: UInt32 {
    get {return _pinnedOrder ?? 0}
    set {_pinnedOrder = newValue}
  }
  /// Returns true if `pinnedOrder` has been explicitly set.
  var hasPinnedOrder: Bool {return self._pinnedOrder != nil}
  /// Clears the value of `pinnedOrder`. Subsequent reads from it will return its default value.
  mutating func clearPinnedOrder() {self._pinnedOrder = nil}

  /// @required
  var expirationTimerMs: UInt64 {
    get {return _expirationTimerMs ?? 0}
    set {_expirationTimerMs = newValue}
  }
  /// Returns true if `expirationTimerMs` has been explicitly set.
  var hasExpirationTimerMs: Bool {return self._expirationTimerMs != nil}
  /// Clears the value of `expirationTimerMs`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTimerMs() {self._expirationTimerMs = nil}

  /// @required
  var muteUntilMs: UInt64 {
    get {return _muteUntilMs ?? 0}
    set {_muteUntilMs = newValue}
  }
  /// Returns true if `muteUntilMs` has been explicitly set.
  var hasMuteUntilMs: Bool {return self._muteUntilMs != nil}
  /// Clears the value of `muteUntilMs`. Subsequent reads from it will return its default value.
  mutating func clearMuteUntilMs() {self._muteUntilMs = nil}

  /// @required
  var markedUnread: Bool {
    get {return _markedUnread ?? false}
    set {_markedUnread = newValue}
  }
  /// Returns true if `markedUnread` has been explicitly set.
  var hasMarkedUnread: Bool {return self._markedUnread != nil}
  /// Clears the value of `markedUnread`. Subsequent reads from it will return its default value.
  mutating func clearMarkedUnread() {self._markedUnread = nil}

  /// @required
  var dontNotifyForMentionsIfMuted: Bool {
    get {return _dontNotifyForMentionsIfMuted ?? false}
    set {_dontNotifyForMentionsIfMuted = newValue}
  }
  /// Returns true if `dontNotifyForMentionsIfMuted` has been explicitly set.
  var hasDontNotifyForMentionsIfMuted: Bool {return self._dontNotifyForMentionsIfMuted != nil}
  /// Clears the value of `dontNotifyForMentionsIfMuted`. Subsequent reads from it will return its default value.
  mutating func clearDontNotifyForMentionsIfMuted() {self._dontNotifyForMentionsIfMuted = nil}

  var wallpaper: BackupProtos_FilePointer {
    get {return _wallpaper ?? BackupProtos_FilePointer()}
    set {_wallpaper = newValue}
  }
  /// Returns true if `wallpaper` has been explicitly set.
  var hasWallpaper: Bool {return self._wallpaper != nil}
  /// Clears the value of `wallpaper`. Subsequent reads from it will return its default value.
  mutating func clearWallpaper() {self._wallpaper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: UInt64? = nil
  fileprivate var _recipientID: UInt64? = nil
  fileprivate var _archived: Bool? = nil
  fileprivate var _pinnedOrder: UInt32? = nil
  fileprivate var _expirationTimerMs: UInt64? = nil
  fileprivate var _muteUntilMs: UInt64? = nil
  fileprivate var _markedUnread: Bool? = nil
  fileprivate var _dontNotifyForMentionsIfMuted: Bool? = nil
  fileprivate var _wallpaper: BackupProtos_FilePointer? = nil
}

struct BackupProtos_DistributionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// @required
  var distributionID: Data {
    get {return _distributionID ?? Data()}
    set {_distributionID = newValue}
  }
  /// Returns true if `distributionID` has been explicitly set.
  var hasDistributionID: Bool {return self._distributionID != nil}
  /// Clears the value of `distributionID`. Subsequent reads from it will return its default value.
  mutating func clearDistributionID() {self._distributionID = nil}

  /// @required
  var allowReplies: Bool {
    get {return _allowReplies ?? false}
    set {_allowReplies = newValue}
  }
  /// Returns true if `allowReplies` has been explicitly set.
  var hasAllowReplies: Bool {return self._allowReplies != nil}
  /// Clears the value of `allowReplies`. Subsequent reads from it will return its default value.
  mutating func clearAllowReplies() {self._allowReplies = nil}

  /// @required
  var deletionTimestamp: UInt64 {
    get {return _deletionTimestamp ?? 0}
    set {_deletionTimestamp = newValue}
  }
  /// Returns true if `deletionTimestamp` has been explicitly set.
  var hasDeletionTimestamp: Bool {return self._deletionTimestamp != nil}
  /// Clears the value of `deletionTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearDeletionTimestamp() {self._deletionTimestamp = nil}

  var privacyMode: BackupProtos_DistributionList.PrivacyMode {
    get {return _privacyMode ?? .unknown}
    set {_privacyMode = newValue}
  }
  /// Returns true if `privacyMode` has been explicitly set.
  var hasPrivacyMode: Bool {return self._privacyMode != nil}
  /// Clears the value of `privacyMode`. Subsequent reads from it will return its default value.
  mutating func clearPrivacyMode() {self._privacyMode = nil}

  /// generated recipient id
  var memberRecipientIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PrivacyMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case onlyWith // = 1
    case allExcept // = 2
    case all // = 3

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .onlyWith
      case 2: self = .allExcept
      case 3: self = .all
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .onlyWith: return 1
      case .allExcept: return 2
      case .all: return 3
      }
    }

  }

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _distributionID: Data? = nil
  fileprivate var _allowReplies: Bool? = nil
  fileprivate var _deletionTimestamp: UInt64? = nil
  fileprivate var _privacyMode: BackupProtos_DistributionList.PrivacyMode? = nil
}

#if swift(>=4.2)

extension BackupProtos_DistributionList.PrivacyMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var serviceID: Data {
    get {return _serviceID ?? Data()}
    set {_serviceID = newValue}
  }
  /// Returns true if `serviceID` has been explicitly set.
  var hasServiceID: Bool {return self._serviceID != nil}
  /// Clears the value of `serviceID`. Subsequent reads from it will return its default value.
  mutating func clearServiceID() {self._serviceID = nil}

  /// @required
  var identityKey: Data {
    get {return _identityKey ?? Data()}
    set {_identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  var hasIdentityKey: Bool {return self._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  mutating func clearIdentityKey() {self._identityKey = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// @required
  var firstUse: Bool {
    get {return _firstUse ?? false}
    set {_firstUse = newValue}
  }
  /// Returns true if `firstUse` has been explicitly set.
  var hasFirstUse: Bool {return self._firstUse != nil}
  /// Clears the value of `firstUse`. Subsequent reads from it will return its default value.
  mutating func clearFirstUse() {self._firstUse = nil}

  /// @required
  var verified: Bool {
    get {return _verified ?? false}
    set {_verified = newValue}
  }
  /// Returns true if `verified` has been explicitly set.
  var hasVerified: Bool {return self._verified != nil}
  /// Clears the value of `verified`. Subsequent reads from it will return its default value.
  mutating func clearVerified() {self._verified = nil}

  /// @required
  var nonblockingApproval: Bool {
    get {return _nonblockingApproval ?? false}
    set {_nonblockingApproval = newValue}
  }
  /// Returns true if `nonblockingApproval` has been explicitly set.
  var hasNonblockingApproval: Bool {return self._nonblockingApproval != nil}
  /// Clears the value of `nonblockingApproval`. Subsequent reads from it will return its default value.
  mutating func clearNonblockingApproval() {self._nonblockingApproval = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceID: Data? = nil
  fileprivate var _identityKey: Data? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _firstUse: Bool? = nil
  fileprivate var _verified: Bool? = nil
  fileprivate var _nonblockingApproval: Bool? = nil
}

struct BackupProtos_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var callID: UInt64 {
    get {return _callID ?? 0}
    set {_callID = newValue}
  }
  /// Returns true if `callID` has been explicitly set.
  var hasCallID: Bool {return self._callID != nil}
  /// Clears the value of `callID`. Subsequent reads from it will return its default value.
  mutating func clearCallID() {self._callID = nil}

  /// @required
  var conversationRecipientID: UInt64 {
    get {return _conversationRecipientID ?? 0}
    set {_conversationRecipientID = newValue}
  }
  /// Returns true if `conversationRecipientID` has been explicitly set.
  var hasConversationRecipientID: Bool {return self._conversationRecipientID != nil}
  /// Clears the value of `conversationRecipientID`. Subsequent reads from it will return its default value.
  mutating func clearConversationRecipientID() {self._conversationRecipientID = nil}

  var type: BackupProtos_Call.TypeEnum {
    get {return _type ?? .unknownType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// @required
  var outgoing: Bool {
    get {return _outgoing ?? false}
    set {_outgoing = newValue}
  }
  /// Returns true if `outgoing` has been explicitly set.
  var hasOutgoing: Bool {return self._outgoing != nil}
  /// Clears the value of `outgoing`. Subsequent reads from it will return its default value.
  mutating func clearOutgoing() {self._outgoing = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// @required
  var ringerRecipientID: UInt64 {
    get {return _ringerRecipientID ?? 0}
    set {_ringerRecipientID = newValue}
  }
  /// Returns true if `ringerRecipientID` has been explicitly set.
  var hasRingerRecipientID: Bool {return self._ringerRecipientID != nil}
  /// Clears the value of `ringerRecipientID`. Subsequent reads from it will return its default value.
  mutating func clearRingerRecipientID() {self._ringerRecipientID = nil}

  var event: BackupProtos_Call.Event {
    get {return _event ?? .unknownEvent}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  mutating func clearEvent() {self._event = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownType // = 0
    case audioCall // = 1
    case videoCall // = 2
    case groupCall // = 3
    case adHocCall // = 4

    init() {
      self = .unknownType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .audioCall
      case 2: self = .videoCall
      case 3: self = .groupCall
      case 4: self = .adHocCall
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .audioCall: return 1
      case .videoCall: return 2
      case .groupCall: return 3
      case .adHocCall: return 4
      }
    }

  }

  enum Event: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownEvent // = 0

    /// 1:1 calls only
    case outgoing // = 1

    /// 1:1 and group calls. Group calls: You accepted a ring.
    case accepted // = 2

    /// 1:1 calls only,
    case notAccepted // = 3

    /// 1:1 and group. Group calls: The remote ring has expired or was cancelled by the ringer.
    case missed // = 4

    /// 1:1 and Group/Ad-Hoc Calls.
    case delete // = 5

    /// Group/Ad-Hoc Calls only. Initial state
    case genericGroupCall // = 6

    /// Group Calls: User has joined the group call.
    case joined // = 7

    /// Group Calls: If you declined a ring.
    case declined // = 8

    /// Group Calls: If you are ringing a group.
    case outgoingRing // = 9

    init() {
      self = .unknownEvent
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownEvent
      case 1: self = .outgoing
      case 2: self = .accepted
      case 3: self = .notAccepted
      case 4: self = .missed
      case 5: self = .delete
      case 6: self = .genericGroupCall
      case 7: self = .joined
      case 8: self = .declined
      case 9: self = .outgoingRing
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownEvent: return 0
      case .outgoing: return 1
      case .accepted: return 2
      case .notAccepted: return 3
      case .missed: return 4
      case .delete: return 5
      case .genericGroupCall: return 6
      case .joined: return 7
      case .declined: return 8
      case .outgoingRing: return 9
      }
    }

  }

  init() {}

  fileprivate var _callID: UInt64? = nil
  fileprivate var _conversationRecipientID: UInt64? = nil
  fileprivate var _type: BackupProtos_Call.TypeEnum? = nil
  fileprivate var _outgoing: Bool? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _ringerRecipientID: UInt64? = nil
  fileprivate var _event: BackupProtos_Call.Event? = nil
}

#if swift(>=4.2)

extension BackupProtos_Call.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_Call.Event: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_ChatItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var chatID: UInt64 {
    get {return _storage._chatID ?? 0}
    set {_uniqueStorage()._chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  var hasChatID: Bool {return _storage._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  mutating func clearChatID() {_uniqueStorage()._chatID = nil}

  /// @required
  var authorID: UInt64 {
    get {return _storage._authorID ?? 0}
    set {_uniqueStorage()._authorID = newValue}
  }
  /// Returns true if `authorID` has been explicitly set.
  var hasAuthorID: Bool {return _storage._authorID != nil}
  /// Clears the value of `authorID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorID() {_uniqueStorage()._authorID = nil}

  /// @required
  var dateSent: UInt64 {
    get {return _storage._dateSent ?? 0}
    set {_uniqueStorage()._dateSent = newValue}
  }
  /// Returns true if `dateSent` has been explicitly set.
  var hasDateSent: Bool {return _storage._dateSent != nil}
  /// Clears the value of `dateSent`. Subsequent reads from it will return its default value.
  mutating func clearDateSent() {_uniqueStorage()._dateSent = nil}

  /// timestamp of when expiration timer started ticking down
  var expireStartMs: UInt64 {
    get {return _storage._expireStartMs ?? 0}
    set {_uniqueStorage()._expireStartMs = newValue}
  }
  /// Returns true if `expireStartMs` has been explicitly set.
  var hasExpireStartMs: Bool {return _storage._expireStartMs != nil}
  /// Clears the value of `expireStartMs`. Subsequent reads from it will return its default value.
  mutating func clearExpireStartMs() {_uniqueStorage()._expireStartMs = nil}

  /// how long timer of message is (ms)
  var expiresInMs: UInt64 {
    get {return _storage._expiresInMs ?? 0}
    set {_uniqueStorage()._expiresInMs = newValue}
  }
  /// Returns true if `expiresInMs` has been explicitly set.
  var hasExpiresInMs: Bool {return _storage._expiresInMs != nil}
  /// Clears the value of `expiresInMs`. Subsequent reads from it will return its default value.
  mutating func clearExpiresInMs() {_uniqueStorage()._expiresInMs = nil}

  /// ordered from oldest to newest
  var revisions: [BackupProtos_ChatItem] {
    get {return _storage._revisions}
    set {_uniqueStorage()._revisions = newValue}
  }

  /// @required
  var sms: Bool {
    get {return _storage._sms ?? false}
    set {_uniqueStorage()._sms = newValue}
  }
  /// Returns true if `sms` has been explicitly set.
  var hasSms: Bool {return _storage._sms != nil}
  /// Clears the value of `sms`. Subsequent reads from it will return its default value.
  mutating func clearSms() {_uniqueStorage()._sms = nil}

  /// oneof directionalDetails {
  var incoming: BackupProtos_ChatItem.IncomingMessageDetails {
    get {return _storage._incoming ?? BackupProtos_ChatItem.IncomingMessageDetails()}
    set {_uniqueStorage()._incoming = newValue}
  }
  /// Returns true if `incoming` has been explicitly set.
  var hasIncoming: Bool {return _storage._incoming != nil}
  /// Clears the value of `incoming`. Subsequent reads from it will return its default value.
  mutating func clearIncoming() {_uniqueStorage()._incoming = nil}

  /// }
  var outgoing: BackupProtos_ChatItem.OutgoingMessageDetails {
    get {return _storage._outgoing ?? BackupProtos_ChatItem.OutgoingMessageDetails()}
    set {_uniqueStorage()._outgoing = newValue}
  }
  /// Returns true if `outgoing` has been explicitly set.
  var hasOutgoing: Bool {return _storage._outgoing != nil}
  /// Clears the value of `outgoing`. Subsequent reads from it will return its default value.
  mutating func clearOutgoing() {_uniqueStorage()._outgoing = nil}

  /// oneof item {
  var standardMessage: BackupProtos_StandardMessage {
    get {return _storage._standardMessage ?? BackupProtos_StandardMessage()}
    set {_uniqueStorage()._standardMessage = newValue}
  }
  /// Returns true if `standardMessage` has been explicitly set.
  var hasStandardMessage: Bool {return _storage._standardMessage != nil}
  /// Clears the value of `standardMessage`. Subsequent reads from it will return its default value.
  mutating func clearStandardMessage() {_uniqueStorage()._standardMessage = nil}

  var contactMessage: BackupProtos_ContactMessage {
    get {return _storage._contactMessage ?? BackupProtos_ContactMessage()}
    set {_uniqueStorage()._contactMessage = newValue}
  }
  /// Returns true if `contactMessage` has been explicitly set.
  var hasContactMessage: Bool {return _storage._contactMessage != nil}
  /// Clears the value of `contactMessage`. Subsequent reads from it will return its default value.
  mutating func clearContactMessage() {_uniqueStorage()._contactMessage = nil}

  var voiceMessage: BackupProtos_VoiceMessage {
    get {return _storage._voiceMessage ?? BackupProtos_VoiceMessage()}
    set {_uniqueStorage()._voiceMessage = newValue}
  }
  /// Returns true if `voiceMessage` has been explicitly set.
  var hasVoiceMessage: Bool {return _storage._voiceMessage != nil}
  /// Clears the value of `voiceMessage`. Subsequent reads from it will return its default value.
  mutating func clearVoiceMessage() {_uniqueStorage()._voiceMessage = nil}

  var stickerMessage: BackupProtos_StickerMessage {
    get {return _storage._stickerMessage ?? BackupProtos_StickerMessage()}
    set {_uniqueStorage()._stickerMessage = newValue}
  }
  /// Returns true if `stickerMessage` has been explicitly set.
  var hasStickerMessage: Bool {return _storage._stickerMessage != nil}
  /// Clears the value of `stickerMessage`. Subsequent reads from it will return its default value.
  mutating func clearStickerMessage() {_uniqueStorage()._stickerMessage = nil}

  var remoteDeletedMessage: BackupProtos_RemoteDeletedMessage {
    get {return _storage._remoteDeletedMessage ?? BackupProtos_RemoteDeletedMessage()}
    set {_uniqueStorage()._remoteDeletedMessage = newValue}
  }
  /// Returns true if `remoteDeletedMessage` has been explicitly set.
  var hasRemoteDeletedMessage: Bool {return _storage._remoteDeletedMessage != nil}
  /// Clears the value of `remoteDeletedMessage`. Subsequent reads from it will return its default value.
  mutating func clearRemoteDeletedMessage() {_uniqueStorage()._remoteDeletedMessage = nil}

  /// }
  var updateMessage: BackupProtos_UpdateMessage {
    get {return _storage._updateMessage ?? BackupProtos_UpdateMessage()}
    set {_uniqueStorage()._updateMessage = newValue}
  }
  /// Returns true if `updateMessage` has been explicitly set.
  var hasUpdateMessage: Bool {return _storage._updateMessage != nil}
  /// Clears the value of `updateMessage`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMessage() {_uniqueStorage()._updateMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct IncomingMessageDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var dateReceived: UInt64 {
      get {return _dateReceived ?? 0}
      set {_dateReceived = newValue}
    }
    /// Returns true if `dateReceived` has been explicitly set.
    var hasDateReceived: Bool {return self._dateReceived != nil}
    /// Clears the value of `dateReceived`. Subsequent reads from it will return its default value.
    mutating func clearDateReceived() {self._dateReceived = nil}

    /// @required
    var dateServerSent: UInt64 {
      get {return _dateServerSent ?? 0}
      set {_dateServerSent = newValue}
    }
    /// Returns true if `dateServerSent` has been explicitly set.
    var hasDateServerSent: Bool {return self._dateServerSent != nil}
    /// Clears the value of `dateServerSent`. Subsequent reads from it will return its default value.
    mutating func clearDateServerSent() {self._dateServerSent = nil}

    /// @required
    var read: Bool {
      get {return _read ?? false}
      set {_read = newValue}
    }
    /// Returns true if `read` has been explicitly set.
    var hasRead: Bool {return self._read != nil}
    /// Clears the value of `read`. Subsequent reads from it will return its default value.
    mutating func clearRead() {self._read = nil}

    /// @required
    var sealedSender: Bool {
      get {return _sealedSender ?? false}
      set {_sealedSender = newValue}
    }
    /// Returns true if `sealedSender` has been explicitly set.
    var hasSealedSender: Bool {return self._sealedSender != nil}
    /// Clears the value of `sealedSender`. Subsequent reads from it will return its default value.
    mutating func clearSealedSender() {self._sealedSender = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _dateReceived: UInt64? = nil
    fileprivate var _dateServerSent: UInt64? = nil
    fileprivate var _read: Bool? = nil
    fileprivate var _sealedSender: Bool? = nil
  }

  struct OutgoingMessageDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sendStatus: [BackupProtos_SendStatus] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_SendStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var recipientID: UInt64 {
    get {return _recipientID ?? 0}
    set {_recipientID = newValue}
  }
  /// Returns true if `recipientID` has been explicitly set.
  var hasRecipientID: Bool {return self._recipientID != nil}
  /// Clears the value of `recipientID`. Subsequent reads from it will return its default value.
  mutating func clearRecipientID() {self._recipientID = nil}

  var deliveryStatus: BackupProtos_SendStatus.Status {
    get {return _deliveryStatus ?? .unknown}
    set {_deliveryStatus = newValue}
  }
  /// Returns true if `deliveryStatus` has been explicitly set.
  var hasDeliveryStatus: Bool {return self._deliveryStatus != nil}
  /// Clears the value of `deliveryStatus`. Subsequent reads from it will return its default value.
  mutating func clearDeliveryStatus() {self._deliveryStatus = nil}

  /// @required
  var networkFailure: Bool {
    get {return _networkFailure ?? false}
    set {_networkFailure = newValue}
  }
  /// Returns true if `networkFailure` has been explicitly set.
  var hasNetworkFailure: Bool {return self._networkFailure != nil}
  /// Clears the value of `networkFailure`. Subsequent reads from it will return its default value.
  mutating func clearNetworkFailure() {self._networkFailure = nil}

  /// @required
  var identityKeyMismatch: Bool {
    get {return _identityKeyMismatch ?? false}
    set {_identityKeyMismatch = newValue}
  }
  /// Returns true if `identityKeyMismatch` has been explicitly set.
  var hasIdentityKeyMismatch: Bool {return self._identityKeyMismatch != nil}
  /// Clears the value of `identityKeyMismatch`. Subsequent reads from it will return its default value.
  mutating func clearIdentityKeyMismatch() {self._identityKeyMismatch = nil}

  /// @required
  var sealedSender: Bool {
    get {return _sealedSender ?? false}
    set {_sealedSender = newValue}
  }
  /// Returns true if `sealedSender` has been explicitly set.
  var hasSealedSender: Bool {return self._sealedSender != nil}
  /// Clears the value of `sealedSender`. Subsequent reads from it will return its default value.
  mutating func clearSealedSender() {self._sealedSender = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case failed // = 1
    case pending // = 2
    case sent // = 3
    case delivered // = 4
    case read // = 5
    case viewed // = 6

    /// e.g. user in group was blocked, so we skipped sending to them
    case skipped // = 7

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .failed
      case 2: self = .pending
      case 3: self = .sent
      case 4: self = .delivered
      case 5: self = .read
      case 6: self = .viewed
      case 7: self = .skipped
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .failed: return 1
      case .pending: return 2
      case .sent: return 3
      case .delivered: return 4
      case .read: return 5
      case .viewed: return 6
      case .skipped: return 7
      }
    }

  }

  init() {}

  fileprivate var _recipientID: UInt64? = nil
  fileprivate var _deliveryStatus: BackupProtos_SendStatus.Status? = nil
  fileprivate var _networkFailure: Bool? = nil
  fileprivate var _identityKeyMismatch: Bool? = nil
  fileprivate var _sealedSender: Bool? = nil
  fileprivate var _timestamp: UInt64? = nil
}

#if swift(>=4.2)

extension BackupProtos_SendStatus.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Text {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var body: String {
    get {return _body ?? String()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  var bodyRanges: [BackupProtos_BodyRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _body: String? = nil
}

struct BackupProtos_StandardMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quote: BackupProtos_Quote {
    get {return _quote ?? BackupProtos_Quote()}
    set {_quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return self._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {self._quote = nil}

  var text: BackupProtos_Text {
    get {return _text ?? BackupProtos_Text()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var attachments: [BackupProtos_FilePointer] = []

  var linkPreview: [BackupProtos_LinkPreview] = []

  var longText: BackupProtos_FilePointer {
    get {return _longText ?? BackupProtos_FilePointer()}
    set {_longText = newValue}
  }
  /// Returns true if `longText` has been explicitly set.
  var hasLongText: Bool {return self._longText != nil}
  /// Clears the value of `longText`. Subsequent reads from it will return its default value.
  mutating func clearLongText() {self._longText = nil}

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _quote: BackupProtos_Quote? = nil
  fileprivate var _text: BackupProtos_Text? = nil
  fileprivate var _longText: BackupProtos_FilePointer? = nil
}

struct BackupProtos_ContactMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contact: [BackupProtos_ContactAttachment] = []

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_ContactAttachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: BackupProtos_ContactAttachment.Name {
    get {return _name ?? BackupProtos_ContactAttachment.Name()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var number: [BackupProtos_ContactAttachment.Phone] = []

  var email: [BackupProtos_ContactAttachment.Email] = []

  var address: [BackupProtos_ContactAttachment.PostalAddress] = []

  var avatar: BackupProtos_ContactAttachment.Avatar {
    get {return _avatar ?? BackupProtos_ContactAttachment.Avatar()}
    set {_avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  var hasAvatar: Bool {return self._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  mutating func clearAvatar() {self._avatar = nil}

  var organization: String {
    get {return _organization ?? String()}
    set {_organization = newValue}
  }
  /// Returns true if `organization` has been explicitly set.
  var hasOrganization: Bool {return self._organization != nil}
  /// Clears the value of `organization`. Subsequent reads from it will return its default value.
  mutating func clearOrganization() {self._organization = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Name {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var givenName: String {
      get {return _givenName ?? String()}
      set {_givenName = newValue}
    }
    /// Returns true if `givenName` has been explicitly set.
    var hasGivenName: Bool {return self._givenName != nil}
    /// Clears the value of `givenName`. Subsequent reads from it will return its default value.
    mutating func clearGivenName() {self._givenName = nil}

    var familyName: String {
      get {return _familyName ?? String()}
      set {_familyName = newValue}
    }
    /// Returns true if `familyName` has been explicitly set.
    var hasFamilyName: Bool {return self._familyName != nil}
    /// Clears the value of `familyName`. Subsequent reads from it will return its default value.
    mutating func clearFamilyName() {self._familyName = nil}

    var prefix: String {
      get {return _prefix ?? String()}
      set {_prefix = newValue}
    }
    /// Returns true if `prefix` has been explicitly set.
    var hasPrefix: Bool {return self._prefix != nil}
    /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
    mutating func clearPrefix() {self._prefix = nil}

    var suffix: String {
      get {return _suffix ?? String()}
      set {_suffix = newValue}
    }
    /// Returns true if `suffix` has been explicitly set.
    var hasSuffix: Bool {return self._suffix != nil}
    /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
    mutating func clearSuffix() {self._suffix = nil}

    var middleName: String {
      get {return _middleName ?? String()}
      set {_middleName = newValue}
    }
    /// Returns true if `middleName` has been explicitly set.
    var hasMiddleName: Bool {return self._middleName != nil}
    /// Clears the value of `middleName`. Subsequent reads from it will return its default value.
    mutating func clearMiddleName() {self._middleName = nil}

    var displayName: String {
      get {return _displayName ?? String()}
      set {_displayName = newValue}
    }
    /// Returns true if `displayName` has been explicitly set.
    var hasDisplayName: Bool {return self._displayName != nil}
    /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
    mutating func clearDisplayName() {self._displayName = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _givenName: String? = nil
    fileprivate var _familyName: String? = nil
    fileprivate var _prefix: String? = nil
    fileprivate var _suffix: String? = nil
    fileprivate var _middleName: String? = nil
    fileprivate var _displayName: String? = nil
  }

  struct Phone {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var type: BackupProtos_ContactAttachment.Phone.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var label: String {
      get {return _label ?? String()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    mutating func clearLabel() {self._label = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case home // = 1
      case mobile // = 2
      case work // = 3
      case custom // = 4

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .home
        case 2: self = .mobile
        case 3: self = .work
        case 4: self = .custom
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .home: return 1
        case .mobile: return 2
        case .work: return 3
        case .custom: return 4
        }
      }

    }

    init() {}

    fileprivate var _value: String? = nil
    fileprivate var _type: BackupProtos_ContactAttachment.Phone.TypeEnum? = nil
    fileprivate var _label: String? = nil
  }

  struct Email {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var type: BackupProtos_ContactAttachment.Email.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var label: String {
      get {return _label ?? String()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    mutating func clearLabel() {self._label = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case home // = 1
      case mobile // = 2
      case work // = 3
      case custom // = 4

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .home
        case 2: self = .mobile
        case 3: self = .work
        case 4: self = .custom
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .home: return 1
        case .mobile: return 2
        case .work: return 3
        case .custom: return 4
        }
      }

    }

    init() {}

    fileprivate var _value: String? = nil
    fileprivate var _type: BackupProtos_ContactAttachment.Email.TypeEnum? = nil
    fileprivate var _label: String? = nil
  }

  struct PostalAddress {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: BackupProtos_ContactAttachment.PostalAddress.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var label: String {
      get {return _label ?? String()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    mutating func clearLabel() {self._label = nil}

    var street: String {
      get {return _street ?? String()}
      set {_street = newValue}
    }
    /// Returns true if `street` has been explicitly set.
    var hasStreet: Bool {return self._street != nil}
    /// Clears the value of `street`. Subsequent reads from it will return its default value.
    mutating func clearStreet() {self._street = nil}

    var pobox: String {
      get {return _pobox ?? String()}
      set {_pobox = newValue}
    }
    /// Returns true if `pobox` has been explicitly set.
    var hasPobox: Bool {return self._pobox != nil}
    /// Clears the value of `pobox`. Subsequent reads from it will return its default value.
    mutating func clearPobox() {self._pobox = nil}

    var neighborhood: String {
      get {return _neighborhood ?? String()}
      set {_neighborhood = newValue}
    }
    /// Returns true if `neighborhood` has been explicitly set.
    var hasNeighborhood: Bool {return self._neighborhood != nil}
    /// Clears the value of `neighborhood`. Subsequent reads from it will return its default value.
    mutating func clearNeighborhood() {self._neighborhood = nil}

    var city: String {
      get {return _city ?? String()}
      set {_city = newValue}
    }
    /// Returns true if `city` has been explicitly set.
    var hasCity: Bool {return self._city != nil}
    /// Clears the value of `city`. Subsequent reads from it will return its default value.
    mutating func clearCity() {self._city = nil}

    var region: String {
      get {return _region ?? String()}
      set {_region = newValue}
    }
    /// Returns true if `region` has been explicitly set.
    var hasRegion: Bool {return self._region != nil}
    /// Clears the value of `region`. Subsequent reads from it will return its default value.
    mutating func clearRegion() {self._region = nil}

    var postcode: String {
      get {return _postcode ?? String()}
      set {_postcode = newValue}
    }
    /// Returns true if `postcode` has been explicitly set.
    var hasPostcode: Bool {return self._postcode != nil}
    /// Clears the value of `postcode`. Subsequent reads from it will return its default value.
    mutating func clearPostcode() {self._postcode = nil}

    var country: String {
      get {return _country ?? String()}
      set {_country = newValue}
    }
    /// Returns true if `country` has been explicitly set.
    var hasCountry: Bool {return self._country != nil}
    /// Clears the value of `country`. Subsequent reads from it will return its default value.
    mutating func clearCountry() {self._country = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case home // = 1
      case work // = 2
      case custom // = 3

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .home
        case 2: self = .work
        case 3: self = .custom
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .home: return 1
        case .work: return 2
        case .custom: return 3
        }
      }

    }

    init() {}

    fileprivate var _type: BackupProtos_ContactAttachment.PostalAddress.TypeEnum? = nil
    fileprivate var _label: String? = nil
    fileprivate var _street: String? = nil
    fileprivate var _pobox: String? = nil
    fileprivate var _neighborhood: String? = nil
    fileprivate var _city: String? = nil
    fileprivate var _region: String? = nil
    fileprivate var _postcode: String? = nil
    fileprivate var _country: String? = nil
  }

  struct Avatar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var avatar: BackupProtos_FilePointer {
      get {return _avatar ?? BackupProtos_FilePointer()}
      set {_avatar = newValue}
    }
    /// Returns true if `avatar` has been explicitly set.
    var hasAvatar: Bool {return self._avatar != nil}
    /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
    mutating func clearAvatar() {self._avatar = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _avatar: BackupProtos_FilePointer? = nil
  }

  init() {}

  fileprivate var _name: BackupProtos_ContactAttachment.Name? = nil
  fileprivate var _avatar: BackupProtos_ContactAttachment.Avatar? = nil
  fileprivate var _organization: String? = nil
}

#if swift(>=4.2)

extension BackupProtos_ContactAttachment.Phone.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_ContactAttachment.Email.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_ContactAttachment.PostalAddress.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_DocumentMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var text: BackupProtos_Text {
    get {return _text ?? BackupProtos_Text()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  /// @required
  var document: BackupProtos_FilePointer {
    get {return _document ?? BackupProtos_FilePointer()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  mutating func clearDocument() {self._document = nil}

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _text: BackupProtos_Text? = nil
  fileprivate var _document: BackupProtos_FilePointer? = nil
}

struct BackupProtos_VoiceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quote: BackupProtos_Quote {
    get {return _quote ?? BackupProtos_Quote()}
    set {_quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return self._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {self._quote = nil}

  /// @required
  var audio: BackupProtos_FilePointer {
    get {return _audio ?? BackupProtos_FilePointer()}
    set {_audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  var hasAudio: Bool {return self._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  mutating func clearAudio() {self._audio = nil}

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _quote: BackupProtos_Quote? = nil
  fileprivate var _audio: BackupProtos_FilePointer? = nil
}

struct BackupProtos_StickerMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var sticker: BackupProtos_Sticker {
    get {return _sticker ?? BackupProtos_Sticker()}
    set {_sticker = newValue}
  }
  /// Returns true if `sticker` has been explicitly set.
  var hasSticker: Bool {return self._sticker != nil}
  /// Clears the value of `sticker`. Subsequent reads from it will return its default value.
  mutating func clearSticker() {self._sticker = nil}

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sticker: BackupProtos_Sticker? = nil
}

/// Tombstone for remote delete
struct BackupProtos_RemoteDeletedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_ScheduledMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var message: BackupProtos_ChatItem {
    get {return _message ?? BackupProtos_ChatItem()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// @required
  var scheduledTime: UInt64 {
    get {return _scheduledTime ?? 0}
    set {_scheduledTime = newValue}
  }
  /// Returns true if `scheduledTime` has been explicitly set.
  var hasScheduledTime: Bool {return self._scheduledTime != nil}
  /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
  mutating func clearScheduledTime() {self._scheduledTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: BackupProtos_ChatItem? = nil
  fileprivate var _scheduledTime: UInt64? = nil
}

struct BackupProtos_Sticker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var packID: Data {
    get {return _packID ?? Data()}
    set {_packID = newValue}
  }
  /// Returns true if `packID` has been explicitly set.
  var hasPackID: Bool {return self._packID != nil}
  /// Clears the value of `packID`. Subsequent reads from it will return its default value.
  mutating func clearPackID() {self._packID = nil}

  /// @required
  var packKey: Data {
    get {return _packKey ?? Data()}
    set {_packKey = newValue}
  }
  /// Returns true if `packKey` has been explicitly set.
  var hasPackKey: Bool {return self._packKey != nil}
  /// Clears the value of `packKey`. Subsequent reads from it will return its default value.
  mutating func clearPackKey() {self._packKey = nil}

  /// @required
  var stickerID: UInt32 {
    get {return _stickerID ?? 0}
    set {_stickerID = newValue}
  }
  /// Returns true if `stickerID` has been explicitly set.
  var hasStickerID: Bool {return self._stickerID != nil}
  /// Clears the value of `stickerID`. Subsequent reads from it will return its default value.
  mutating func clearStickerID() {self._stickerID = nil}

  var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  mutating func clearEmoji() {self._emoji = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _packID: Data? = nil
  fileprivate var _packKey: Data? = nil
  fileprivate var _stickerID: UInt32? = nil
  fileprivate var _emoji: String? = nil
}

struct BackupProtos_LinkPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var image: BackupProtos_FilePointer {
    get {return _image ?? BackupProtos_FilePointer()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {self._image = nil}

  var descriptionText: String {
    get {return _descriptionText ?? String()}
    set {_descriptionText = newValue}
  }
  /// Returns true if `descriptionText` has been explicitly set.
  var hasDescriptionText: Bool {return self._descriptionText != nil}
  /// Clears the value of `descriptionText`. Subsequent reads from it will return its default value.
  mutating func clearDescriptionText() {self._descriptionText = nil}

  var date: UInt64 {
    get {return _date ?? 0}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _url: String? = nil
  fileprivate var _title: String? = nil
  fileprivate var _image: BackupProtos_FilePointer? = nil
  fileprivate var _descriptionText: String? = nil
  fileprivate var _date: UInt64? = nil
}

struct BackupProtos_FilePointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof locator {
  var backupLocator: BackupProtos_FilePointer.BackupLocator {
    get {return _storage._backupLocator ?? BackupProtos_FilePointer.BackupLocator()}
    set {_uniqueStorage()._backupLocator = newValue}
  }
  /// Returns true if `backupLocator` has been explicitly set.
  var hasBackupLocator: Bool {return _storage._backupLocator != nil}
  /// Clears the value of `backupLocator`. Subsequent reads from it will return its default value.
  mutating func clearBackupLocator() {_uniqueStorage()._backupLocator = nil}

  var attachmentLocator: BackupProtos_FilePointer.AttachmentLocator {
    get {return _storage._attachmentLocator ?? BackupProtos_FilePointer.AttachmentLocator()}
    set {_uniqueStorage()._attachmentLocator = newValue}
  }
  /// Returns true if `attachmentLocator` has been explicitly set.
  var hasAttachmentLocator: Bool {return _storage._attachmentLocator != nil}
  /// Clears the value of `attachmentLocator`. Subsequent reads from it will return its default value.
  mutating func clearAttachmentLocator() {_uniqueStorage()._attachmentLocator = nil}

  /// }
  var legacyAttachmentLocator: BackupProtos_FilePointer.LegacyAttachmentLocator {
    get {return _storage._legacyAttachmentLocator ?? BackupProtos_FilePointer.LegacyAttachmentLocator()}
    set {_uniqueStorage()._legacyAttachmentLocator = newValue}
  }
  /// Returns true if `legacyAttachmentLocator` has been explicitly set.
  var hasLegacyAttachmentLocator: Bool {return _storage._legacyAttachmentLocator != nil}
  /// Clears the value of `legacyAttachmentLocator`. Subsequent reads from it will return its default value.
  mutating func clearLegacyAttachmentLocator() {_uniqueStorage()._legacyAttachmentLocator = nil}

  var key: Data {
    get {return _storage._key ?? Data()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  var contentType: String {
    get {return _storage._contentType ?? String()}
    set {_uniqueStorage()._contentType = newValue}
  }
  /// Returns true if `contentType` has been explicitly set.
  var hasContentType: Bool {return _storage._contentType != nil}
  /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
  mutating func clearContentType() {_uniqueStorage()._contentType = nil}

  var size: UInt32 {
    get {return _storage._size ?? 0}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return _storage._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {_uniqueStorage()._size = nil}

  var digest: Data {
    get {return _storage._digest ?? Data()}
    set {_uniqueStorage()._digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  var hasDigest: Bool {return _storage._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  mutating func clearDigest() {_uniqueStorage()._digest = nil}

  var incrementalMac: Data {
    get {return _storage._incrementalMac ?? Data()}
    set {_uniqueStorage()._incrementalMac = newValue}
  }
  /// Returns true if `incrementalMac` has been explicitly set.
  var hasIncrementalMac: Bool {return _storage._incrementalMac != nil}
  /// Clears the value of `incrementalMac`. Subsequent reads from it will return its default value.
  mutating func clearIncrementalMac() {_uniqueStorage()._incrementalMac = nil}

  var incrementalMacChunkSize: Data {
    get {return _storage._incrementalMacChunkSize ?? Data()}
    set {_uniqueStorage()._incrementalMacChunkSize = newValue}
  }
  /// Returns true if `incrementalMacChunkSize` has been explicitly set.
  var hasIncrementalMacChunkSize: Bool {return _storage._incrementalMacChunkSize != nil}
  /// Clears the value of `incrementalMacChunkSize`. Subsequent reads from it will return its default value.
  mutating func clearIncrementalMacChunkSize() {_uniqueStorage()._incrementalMacChunkSize = nil}

  var fileName: String {
    get {return _storage._fileName ?? String()}
    set {_uniqueStorage()._fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return _storage._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {_uniqueStorage()._fileName = nil}

  var flags: UInt32 {
    get {return _storage._flags ?? 0}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {_uniqueStorage()._flags = nil}

  var width: UInt32 {
    get {return _storage._width ?? 0}
    set {_uniqueStorage()._width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return _storage._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {_uniqueStorage()._width = nil}

  var height: UInt32 {
    get {return _storage._height ?? 0}
    set {_uniqueStorage()._height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return _storage._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {_uniqueStorage()._height = nil}

  var caption: String {
    get {return _storage._caption ?? String()}
    set {_uniqueStorage()._caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  var hasCaption: Bool {return _storage._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  mutating func clearCaption() {_uniqueStorage()._caption = nil}

  var blurHash: String {
    get {return _storage._blurHash ?? String()}
    set {_uniqueStorage()._blurHash = newValue}
  }
  /// Returns true if `blurHash` has been explicitly set.
  var hasBlurHash: Bool {return _storage._blurHash != nil}
  /// Clears the value of `blurHash`. Subsequent reads from it will return its default value.
  mutating func clearBlurHash() {_uniqueStorage()._blurHash = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case voiceMessage // = 0
    case borderless // = 1
    case gif // = 2

    init() {
      self = .voiceMessage
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .voiceMessage
      case 1: self = .borderless
      case 2: self = .gif
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .voiceMessage: return 0
      case .borderless: return 1
      case .gif: return 2
      }
    }

  }

  struct BackupLocator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var mediaName: String {
      get {return _mediaName ?? String()}
      set {_mediaName = newValue}
    }
    /// Returns true if `mediaName` has been explicitly set.
    var hasMediaName: Bool {return self._mediaName != nil}
    /// Clears the value of `mediaName`. Subsequent reads from it will return its default value.
    mutating func clearMediaName() {self._mediaName = nil}

    /// @required
    var cdnNumber: UInt32 {
      get {return _cdnNumber ?? 0}
      set {_cdnNumber = newValue}
    }
    /// Returns true if `cdnNumber` has been explicitly set.
    var hasCdnNumber: Bool {return self._cdnNumber != nil}
    /// Clears the value of `cdnNumber`. Subsequent reads from it will return its default value.
    mutating func clearCdnNumber() {self._cdnNumber = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mediaName: String? = nil
    fileprivate var _cdnNumber: UInt32? = nil
  }

  struct AttachmentLocator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var cdnKey: String {
      get {return _cdnKey ?? String()}
      set {_cdnKey = newValue}
    }
    /// Returns true if `cdnKey` has been explicitly set.
    var hasCdnKey: Bool {return self._cdnKey != nil}
    /// Clears the value of `cdnKey`. Subsequent reads from it will return its default value.
    mutating func clearCdnKey() {self._cdnKey = nil}

    /// @required
    var cdnNumber: UInt32 {
      get {return _cdnNumber ?? 0}
      set {_cdnNumber = newValue}
    }
    /// Returns true if `cdnNumber` has been explicitly set.
    var hasCdnNumber: Bool {return self._cdnNumber != nil}
    /// Clears the value of `cdnNumber`. Subsequent reads from it will return its default value.
    mutating func clearCdnNumber() {self._cdnNumber = nil}

    /// @required
    var uploadTimestamp: UInt64 {
      get {return _uploadTimestamp ?? 0}
      set {_uploadTimestamp = newValue}
    }
    /// Returns true if `uploadTimestamp` has been explicitly set.
    var hasUploadTimestamp: Bool {return self._uploadTimestamp != nil}
    /// Clears the value of `uploadTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearUploadTimestamp() {self._uploadTimestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _cdnKey: String? = nil
    fileprivate var _cdnNumber: UInt32? = nil
    fileprivate var _uploadTimestamp: UInt64? = nil
  }

  struct LegacyAttachmentLocator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension BackupProtos_FilePointer.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Quote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// null if the target message could not be found at time of quote insert
  var targetSentTimestamp: UInt64 {
    get {return _targetSentTimestamp ?? 0}
    set {_targetSentTimestamp = newValue}
  }
  /// Returns true if `targetSentTimestamp` has been explicitly set.
  var hasTargetSentTimestamp: Bool {return self._targetSentTimestamp != nil}
  /// Clears the value of `targetSentTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearTargetSentTimestamp() {self._targetSentTimestamp = nil}

  /// @required
  var authorID: UInt64 {
    get {return _authorID ?? 0}
    set {_authorID = newValue}
  }
  /// Returns true if `authorID` has been explicitly set.
  var hasAuthorID: Bool {return self._authorID != nil}
  /// Clears the value of `authorID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorID() {self._authorID = nil}

  var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var attachments: [BackupProtos_Quote.QuotedAttachment] = []

  var bodyRanges: [BackupProtos_BodyRange] = []

  var type: BackupProtos_Quote.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case normal // = 1
    case giftbadge // = 2

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .normal
      case 2: self = .giftbadge
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .normal: return 1
      case .giftbadge: return 2
      }
    }

  }

  struct QuotedAttachment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var contentType: String {
      get {return _contentType ?? String()}
      set {_contentType = newValue}
    }
    /// Returns true if `contentType` has been explicitly set.
    var hasContentType: Bool {return self._contentType != nil}
    /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
    mutating func clearContentType() {self._contentType = nil}

    var fileName: String {
      get {return _fileName ?? String()}
      set {_fileName = newValue}
    }
    /// Returns true if `fileName` has been explicitly set.
    var hasFileName: Bool {return self._fileName != nil}
    /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
    mutating func clearFileName() {self._fileName = nil}

    var thumbnail: BackupProtos_FilePointer {
      get {return _thumbnail ?? BackupProtos_FilePointer()}
      set {_thumbnail = newValue}
    }
    /// Returns true if `thumbnail` has been explicitly set.
    var hasThumbnail: Bool {return self._thumbnail != nil}
    /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
    mutating func clearThumbnail() {self._thumbnail = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _contentType: String? = nil
    fileprivate var _fileName: String? = nil
    fileprivate var _thumbnail: BackupProtos_FilePointer? = nil
  }

  init() {}

  fileprivate var _targetSentTimestamp: UInt64? = nil
  fileprivate var _authorID: UInt64? = nil
  fileprivate var _text: String? = nil
  fileprivate var _type: BackupProtos_Quote.TypeEnum? = nil
}

#if swift(>=4.2)

extension BackupProtos_Quote.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_BodyRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: UInt32 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var length: UInt32 {
    get {return _length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  var hasLength: Bool {return self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  mutating func clearLength() {self._length = nil}

  /// oneof associatedValue {
  var mentionAci: Data {
    get {return _mentionAci ?? Data()}
    set {_mentionAci = newValue}
  }
  /// Returns true if `mentionAci` has been explicitly set.
  var hasMentionAci: Bool {return self._mentionAci != nil}
  /// Clears the value of `mentionAci`. Subsequent reads from it will return its default value.
  mutating func clearMentionAci() {self._mentionAci = nil}

  /// }
  var style: BackupProtos_BodyRange.Style {
    get {return _style ?? .none}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Style: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case bold // = 1
    case italic // = 2
    case spoiler // = 3
    case strikethrough // = 4
    case monospace // = 5

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .bold
      case 2: self = .italic
      case 3: self = .spoiler
      case 4: self = .strikethrough
      case 5: self = .monospace
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .bold: return 1
      case .italic: return 2
      case .spoiler: return 3
      case .strikethrough: return 4
      case .monospace: return 5
      }
    }

  }

  init() {}

  fileprivate var _start: UInt32? = nil
  fileprivate var _length: UInt32? = nil
  fileprivate var _mentionAci: Data? = nil
  fileprivate var _style: BackupProtos_BodyRange.Style? = nil
}

#if swift(>=4.2)

extension BackupProtos_BodyRange.Style: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Reaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  mutating func clearEmoji() {self._emoji = nil}

  /// @required
  var authorID: UInt64 {
    get {return _authorID ?? 0}
    set {_authorID = newValue}
  }
  /// Returns true if `authorID` has been explicitly set.
  var hasAuthorID: Bool {return self._authorID != nil}
  /// Clears the value of `authorID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorID() {self._authorID = nil}

  /// @required
  var sentTimestamp: UInt64 {
    get {return _sentTimestamp ?? 0}
    set {_sentTimestamp = newValue}
  }
  /// Returns true if `sentTimestamp` has been explicitly set.
  var hasSentTimestamp: Bool {return self._sentTimestamp != nil}
  /// Clears the value of `sentTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearSentTimestamp() {self._sentTimestamp = nil}

  /// @required
  var receivedTimestamp: UInt64 {
    get {return _receivedTimestamp ?? 0}
    set {_receivedTimestamp = newValue}
  }
  /// Returns true if `receivedTimestamp` has been explicitly set.
  var hasReceivedTimestamp: Bool {return self._receivedTimestamp != nil}
  /// Clears the value of `receivedTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearReceivedTimestamp() {self._receivedTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _emoji: String? = nil
  fileprivate var _authorID: UInt64? = nil
  fileprivate var _sentTimestamp: UInt64? = nil
  fileprivate var _receivedTimestamp: UInt64? = nil
}

struct BackupProtos_UpdateMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof update {
  var simpleUpdate: BackupProtos_SimpleUpdate {
    get {return _simpleUpdate ?? BackupProtos_SimpleUpdate()}
    set {_simpleUpdate = newValue}
  }
  /// Returns true if `simpleUpdate` has been explicitly set.
  var hasSimpleUpdate: Bool {return self._simpleUpdate != nil}
  /// Clears the value of `simpleUpdate`. Subsequent reads from it will return its default value.
  mutating func clearSimpleUpdate() {self._simpleUpdate = nil}

  var groupDescription: BackupProtos_GroupDescriptionUpdate {
    get {return _groupDescription ?? BackupProtos_GroupDescriptionUpdate()}
    set {_groupDescription = newValue}
  }
  /// Returns true if `groupDescription` has been explicitly set.
  var hasGroupDescription: Bool {return self._groupDescription != nil}
  /// Clears the value of `groupDescription`. Subsequent reads from it will return its default value.
  mutating func clearGroupDescription() {self._groupDescription = nil}

  var expirationTimerChange: BackupProtos_ExpirationTimerChange {
    get {return _expirationTimerChange ?? BackupProtos_ExpirationTimerChange()}
    set {_expirationTimerChange = newValue}
  }
  /// Returns true if `expirationTimerChange` has been explicitly set.
  var hasExpirationTimerChange: Bool {return self._expirationTimerChange != nil}
  /// Clears the value of `expirationTimerChange`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTimerChange() {self._expirationTimerChange = nil}

  var profileChange: BackupProtos_ProfileChange {
    get {return _profileChange ?? BackupProtos_ProfileChange()}
    set {_profileChange = newValue}
  }
  /// Returns true if `profileChange` has been explicitly set.
  var hasProfileChange: Bool {return self._profileChange != nil}
  /// Clears the value of `profileChange`. Subsequent reads from it will return its default value.
  mutating func clearProfileChange() {self._profileChange = nil}

  var threadMerge: BackupProtos_ThreadMergeEvent {
    get {return _threadMerge ?? BackupProtos_ThreadMergeEvent()}
    set {_threadMerge = newValue}
  }
  /// Returns true if `threadMerge` has been explicitly set.
  var hasThreadMerge: Bool {return self._threadMerge != nil}
  /// Clears the value of `threadMerge`. Subsequent reads from it will return its default value.
  mutating func clearThreadMerge() {self._threadMerge = nil}

  var sessionSwitchover: BackupProtos_SessionSwitchoverEvent {
    get {return _sessionSwitchover ?? BackupProtos_SessionSwitchoverEvent()}
    set {_sessionSwitchover = newValue}
  }
  /// Returns true if `sessionSwitchover` has been explicitly set.
  var hasSessionSwitchover: Bool {return self._sessionSwitchover != nil}
  /// Clears the value of `sessionSwitchover`. Subsequent reads from it will return its default value.
  mutating func clearSessionSwitchover() {self._sessionSwitchover = nil}

  /// }
  var callingMessage: BackupProtos_CallingMessage {
    get {return _callingMessage ?? BackupProtos_CallingMessage()}
    set {_callingMessage = newValue}
  }
  /// Returns true if `callingMessage` has been explicitly set.
  var hasCallingMessage: Bool {return self._callingMessage != nil}
  /// Clears the value of `callingMessage`. Subsequent reads from it will return its default value.
  mutating func clearCallingMessage() {self._callingMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _simpleUpdate: BackupProtos_SimpleUpdate? = nil
  fileprivate var _groupDescription: BackupProtos_GroupDescriptionUpdate? = nil
  fileprivate var _expirationTimerChange: BackupProtos_ExpirationTimerChange? = nil
  fileprivate var _profileChange: BackupProtos_ProfileChange? = nil
  fileprivate var _threadMerge: BackupProtos_ThreadMergeEvent? = nil
  fileprivate var _sessionSwitchover: BackupProtos_SessionSwitchoverEvent? = nil
  fileprivate var _callingMessage: BackupProtos_CallingMessage? = nil
}

struct BackupProtos_CallingMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof call {
  var callID: UInt64 {
    get {return _callID ?? 0}
    set {_callID = newValue}
  }
  /// Returns true if `callID` has been explicitly set.
  var hasCallID: Bool {return self._callID != nil}
  /// Clears the value of `callID`. Subsequent reads from it will return its default value.
  mutating func clearCallID() {self._callID = nil}

  var callMessage: BackupProtos_CallMessage {
    get {return _callMessage ?? BackupProtos_CallMessage()}
    set {_callMessage = newValue}
  }
  /// Returns true if `callMessage` has been explicitly set.
  var hasCallMessage: Bool {return self._callMessage != nil}
  /// Clears the value of `callMessage`. Subsequent reads from it will return its default value.
  mutating func clearCallMessage() {self._callMessage = nil}

  /// }
  var groupCall: BackupProtos_GroupCallMessage {
    get {return _groupCall ?? BackupProtos_GroupCallMessage()}
    set {_groupCall = newValue}
  }
  /// Returns true if `groupCall` has been explicitly set.
  var hasGroupCall: Bool {return self._groupCall != nil}
  /// Clears the value of `groupCall`. Subsequent reads from it will return its default value.
  mutating func clearGroupCall() {self._groupCall = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _callID: UInt64? = nil
  fileprivate var _callMessage: BackupProtos_CallMessage? = nil
  fileprivate var _groupCall: BackupProtos_GroupCallMessage? = nil
}

struct BackupProtos_CallMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case incomingAudioCall // = 1
    case incomingVideoCall // = 2
    case outgoingAudioCall // = 3
    case outgoingVideoCall // = 4
    case missedAudioCall // = 5
    case missedVideoCall // = 6

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .incomingAudioCall
      case 2: self = .incomingVideoCall
      case 3: self = .outgoingAudioCall
      case 4: self = .outgoingVideoCall
      case 5: self = .missedAudioCall
      case 6: self = .missedVideoCall
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .incomingAudioCall: return 1
      case .incomingVideoCall: return 2
      case .outgoingAudioCall: return 3
      case .outgoingVideoCall: return 4
      case .missedAudioCall: return 5
      case .missedVideoCall: return 6
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension BackupProtos_CallMessage.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_GroupCallMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var startedCallAci: Data {
    get {return _startedCallAci ?? Data()}
    set {_startedCallAci = newValue}
  }
  /// Returns true if `startedCallAci` has been explicitly set.
  var hasStartedCallAci: Bool {return self._startedCallAci != nil}
  /// Clears the value of `startedCallAci`. Subsequent reads from it will return its default value.
  mutating func clearStartedCallAci() {self._startedCallAci = nil}

  /// @required
  var startedCallTimestamp: UInt64 {
    get {return _startedCallTimestamp ?? 0}
    set {_startedCallTimestamp = newValue}
  }
  /// Returns true if `startedCallTimestamp` has been explicitly set.
  var hasStartedCallTimestamp: Bool {return self._startedCallTimestamp != nil}
  /// Clears the value of `startedCallTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearStartedCallTimestamp() {self._startedCallTimestamp = nil}

  var inCallAcis: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startedCallAci: Data? = nil
  fileprivate var _startedCallTimestamp: UInt64? = nil
}

struct BackupProtos_SimpleUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: BackupProtos_SimpleUpdate.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case joinedSignal // = 1
    case identityUpdate // = 2
    case identityVerified // = 3

    /// marking as unverified
    case identityDefault // = 4
    case changeNumber // = 5
    case boostRequest // = 6
    case endSession // = 7
    case chatSessionRefresh // = 8
    case badDecrypt // = 9
    case paymentsActivated // = 10
    case paymentActivationRequest // = 11

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .joinedSignal
      case 2: self = .identityUpdate
      case 3: self = .identityVerified
      case 4: self = .identityDefault
      case 5: self = .changeNumber
      case 6: self = .boostRequest
      case 7: self = .endSession
      case 8: self = .chatSessionRefresh
      case 9: self = .badDecrypt
      case 10: self = .paymentsActivated
      case 11: self = .paymentActivationRequest
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .joinedSignal: return 1
      case .identityUpdate: return 2
      case .identityVerified: return 3
      case .identityDefault: return 4
      case .changeNumber: return 5
      case .boostRequest: return 6
      case .endSession: return 7
      case .chatSessionRefresh: return 8
      case .badDecrypt: return 9
      case .paymentsActivated: return 10
      case .paymentActivationRequest: return 11
      }
    }

  }

  init() {}

  fileprivate var _type: BackupProtos_SimpleUpdate.TypeEnum? = nil
}

#if swift(>=4.2)

extension BackupProtos_SimpleUpdate.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_GroupDescriptionUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var newDescription: String {
    get {return _newDescription ?? String()}
    set {_newDescription = newValue}
  }
  /// Returns true if `newDescription` has been explicitly set.
  var hasNewDescription: Bool {return self._newDescription != nil}
  /// Clears the value of `newDescription`. Subsequent reads from it will return its default value.
  mutating func clearNewDescription() {self._newDescription = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newDescription: String? = nil
}

struct BackupProtos_ExpirationTimerChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var expiresInMs: UInt32 {
    get {return _expiresInMs ?? 0}
    set {_expiresInMs = newValue}
  }
  /// Returns true if `expiresInMs` has been explicitly set.
  var hasExpiresInMs: Bool {return self._expiresInMs != nil}
  /// Clears the value of `expiresInMs`. Subsequent reads from it will return its default value.
  mutating func clearExpiresInMs() {self._expiresInMs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiresInMs: UInt32? = nil
}

struct BackupProtos_ProfileChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var previousName: String {
    get {return _previousName ?? String()}
    set {_previousName = newValue}
  }
  /// Returns true if `previousName` has been explicitly set.
  var hasPreviousName: Bool {return self._previousName != nil}
  /// Clears the value of `previousName`. Subsequent reads from it will return its default value.
  mutating func clearPreviousName() {self._previousName = nil}

  /// @required
  var newName: String {
    get {return _newName ?? String()}
    set {_newName = newValue}
  }
  /// Returns true if `newName` has been explicitly set.
  var hasNewName: Bool {return self._newName != nil}
  /// Clears the value of `newName`. Subsequent reads from it will return its default value.
  mutating func clearNewName() {self._newName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _previousName: String? = nil
  fileprivate var _newName: String? = nil
}

struct BackupProtos_ThreadMergeEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var previousE164: UInt64 {
    get {return _previousE164 ?? 0}
    set {_previousE164 = newValue}
  }
  /// Returns true if `previousE164` has been explicitly set.
  var hasPreviousE164: Bool {return self._previousE164 != nil}
  /// Clears the value of `previousE164`. Subsequent reads from it will return its default value.
  mutating func clearPreviousE164() {self._previousE164 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _previousE164: UInt64? = nil
}

struct BackupProtos_SessionSwitchoverEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var e164: UInt64 {
    get {return _e164 ?? 0}
    set {_e164 = newValue}
  }
  /// Returns true if `e164` has been explicitly set.
  var hasE164: Bool {return self._e164 != nil}
  /// Clears the value of `e164`. Subsequent reads from it will return its default value.
  mutating func clearE164() {self._e164 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _e164: UInt64? = nil
}

struct BackupProtos_StickerPack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: Data {
    get {return _id ?? Data()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// @required
  var key: Data {
    get {return _key ?? Data()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// @required
  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  /// @required
  var author: String {
    get {return _author ?? String()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  mutating func clearAuthor() {self._author = nil}

  /// First one should be cover sticker.
  var stickers: [BackupProtos_StickerPackSticker] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Data? = nil
  fileprivate var _key: Data? = nil
  fileprivate var _title: String? = nil
  fileprivate var _author: String? = nil
}

struct BackupProtos_StickerPackSticker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var data: BackupProtos_FilePointer {
    get {return _data ?? BackupProtos_FilePointer()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  /// @required
  var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  mutating func clearEmoji() {self._emoji = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: BackupProtos_FilePointer? = nil
  fileprivate var _emoji: String? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension BackupProtos_BackupInfo: @unchecked Sendable {}
extension BackupProtos_Frame: @unchecked Sendable {}
extension BackupProtos_AccountData: @unchecked Sendable {}
extension BackupProtos_AccountData.PhoneNumberSharingMode: @unchecked Sendable {}
extension BackupProtos_AccountData.UsernameLink: @unchecked Sendable {}
extension BackupProtos_AccountData.UsernameLink.Color: @unchecked Sendable {}
extension BackupProtos_AccountData.AccountSettings: @unchecked Sendable {}
extension BackupProtos_Recipient: @unchecked Sendable {}
extension BackupProtos_Contact: @unchecked Sendable {}
extension BackupProtos_Contact.Registered: @unchecked Sendable {}
extension BackupProtos_Group: @unchecked Sendable {}
extension BackupProtos_Group.StorySendMode: @unchecked Sendable {}
extension BackupProtos_SelfRecipient: @unchecked Sendable {}
extension BackupProtos_ReleaseNotes: @unchecked Sendable {}
extension BackupProtos_Chat: @unchecked Sendable {}
extension BackupProtos_DistributionList: @unchecked Sendable {}
extension BackupProtos_DistributionList.PrivacyMode: @unchecked Sendable {}
extension BackupProtos_Identity: @unchecked Sendable {}
extension BackupProtos_Call: @unchecked Sendable {}
extension BackupProtos_Call.TypeEnum: @unchecked Sendable {}
extension BackupProtos_Call.Event: @unchecked Sendable {}
extension BackupProtos_ChatItem: @unchecked Sendable {}
extension BackupProtos_ChatItem.IncomingMessageDetails: @unchecked Sendable {}
extension BackupProtos_ChatItem.OutgoingMessageDetails: @unchecked Sendable {}
extension BackupProtos_SendStatus: @unchecked Sendable {}
extension BackupProtos_SendStatus.Status: @unchecked Sendable {}
extension BackupProtos_Text: @unchecked Sendable {}
extension BackupProtos_StandardMessage: @unchecked Sendable {}
extension BackupProtos_ContactMessage: @unchecked Sendable {}
extension BackupProtos_ContactAttachment: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Name: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Phone: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Phone.TypeEnum: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Email: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Email.TypeEnum: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.PostalAddress: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.PostalAddress.TypeEnum: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Avatar: @unchecked Sendable {}
extension BackupProtos_DocumentMessage: @unchecked Sendable {}
extension BackupProtos_VoiceMessage: @unchecked Sendable {}
extension BackupProtos_StickerMessage: @unchecked Sendable {}
extension BackupProtos_RemoteDeletedMessage: @unchecked Sendable {}
extension BackupProtos_ScheduledMessage: @unchecked Sendable {}
extension BackupProtos_Sticker: @unchecked Sendable {}
extension BackupProtos_LinkPreview: @unchecked Sendable {}
extension BackupProtos_FilePointer: @unchecked Sendable {}
extension BackupProtos_FilePointer.Flags: @unchecked Sendable {}
extension BackupProtos_FilePointer.BackupLocator: @unchecked Sendable {}
extension BackupProtos_FilePointer.AttachmentLocator: @unchecked Sendable {}
extension BackupProtos_FilePointer.LegacyAttachmentLocator: @unchecked Sendable {}
extension BackupProtos_Quote: @unchecked Sendable {}
extension BackupProtos_Quote.TypeEnum: @unchecked Sendable {}
extension BackupProtos_Quote.QuotedAttachment: @unchecked Sendable {}
extension BackupProtos_BodyRange: @unchecked Sendable {}
extension BackupProtos_BodyRange.Style: @unchecked Sendable {}
extension BackupProtos_Reaction: @unchecked Sendable {}
extension BackupProtos_UpdateMessage: @unchecked Sendable {}
extension BackupProtos_CallingMessage: @unchecked Sendable {}
extension BackupProtos_CallMessage: @unchecked Sendable {}
extension BackupProtos_CallMessage.TypeEnum: @unchecked Sendable {}
extension BackupProtos_GroupCallMessage: @unchecked Sendable {}
extension BackupProtos_SimpleUpdate: @unchecked Sendable {}
extension BackupProtos_SimpleUpdate.TypeEnum: @unchecked Sendable {}
extension BackupProtos_GroupDescriptionUpdate: @unchecked Sendable {}
extension BackupProtos_ExpirationTimerChange: @unchecked Sendable {}
extension BackupProtos_ProfileChange: @unchecked Sendable {}
extension BackupProtos_ThreadMergeEvent: @unchecked Sendable {}
extension BackupProtos_SessionSwitchoverEvent: @unchecked Sendable {}
extension BackupProtos_StickerPack: @unchecked Sendable {}
extension BackupProtos_StickerPackSticker: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "BackupProtos"

extension BackupProtos_BackupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BackupInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "backupTimeMs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._version) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._backupTimeMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._backupTimeMs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_BackupInfo, rhs: BackupProtos_BackupInfo) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._backupTimeMs != rhs._backupTimeMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Frame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "recipient"),
    3: .same(proto: "chat"),
    4: .same(proto: "chatItem"),
    5: .same(proto: "call"),
    6: .same(proto: "stickerPack"),
  ]

  fileprivate class _StorageClass {
    var _account: BackupProtos_AccountData? = nil
    var _recipient: BackupProtos_Recipient? = nil
    var _chat: BackupProtos_Chat? = nil
    var _chatItem: BackupProtos_ChatItem? = nil
    var _call: BackupProtos_Call? = nil
    var _stickerPack: BackupProtos_StickerPack? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _recipient = source._recipient
      _chat = source._chat
      _chatItem = source._chatItem
      _call = source._call
      _stickerPack = source._stickerPack
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._account) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._recipient) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._chat) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._chatItem) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._call) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._stickerPack) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._recipient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._chat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._chatItem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._call {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._stickerPack {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Frame, rhs: BackupProtos_Frame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._recipient != rhs_storage._recipient {return false}
        if _storage._chat != rhs_storage._chat {return false}
        if _storage._chatItem != rhs_storage._chatItem {return false}
        if _storage._call != rhs_storage._call {return false}
        if _storage._stickerPack != rhs_storage._stickerPack {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AccountData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profileKey"),
    2: .same(proto: "username"),
    3: .same(proto: "usernameLink"),
    4: .same(proto: "givenName"),
    5: .same(proto: "familyName"),
    6: .same(proto: "avatarPath"),
    7: .same(proto: "subscriberId"),
    8: .same(proto: "subscriberCurrencyCode"),
    9: .same(proto: "subscriptionManuallyCancelled"),
    10: .same(proto: "accountSettings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._profileKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usernameLink) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._givenName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._familyName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._avatarPath) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._subscriberID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._subscriberCurrencyCode) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._subscriptionManuallyCancelled) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._accountSettings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._profileKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._usernameLink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._givenName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._familyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._avatarPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._subscriberID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._subscriberCurrencyCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._subscriptionManuallyCancelled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._accountSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_AccountData, rhs: BackupProtos_AccountData) -> Bool {
    if lhs._profileKey != rhs._profileKey {return false}
    if lhs._username != rhs._username {return false}
    if lhs._usernameLink != rhs._usernameLink {return false}
    if lhs._givenName != rhs._givenName {return false}
    if lhs._familyName != rhs._familyName {return false}
    if lhs._avatarPath != rhs._avatarPath {return false}
    if lhs._subscriberID != rhs._subscriberID {return false}
    if lhs._subscriberCurrencyCode != rhs._subscriberCurrencyCode {return false}
    if lhs._subscriptionManuallyCancelled != rhs._subscriptionManuallyCancelled {return false}
    if lhs._accountSettings != rhs._accountSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AccountData.PhoneNumberSharingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "EVERYBODY"),
    2: .same(proto: "NOBODY"),
  ]
}

extension BackupProtos_AccountData.UsernameLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_AccountData.protoMessageName + ".UsernameLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entropy"),
    2: .same(proto: "serverId"),
    3: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._entropy) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entropy {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._serverID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_AccountData.UsernameLink, rhs: BackupProtos_AccountData.UsernameLink) -> Bool {
    if lhs._entropy != rhs._entropy {return false}
    if lhs._serverID != rhs._serverID {return false}
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AccountData.UsernameLink.Color: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BLUE"),
    2: .same(proto: "WHITE"),
    3: .same(proto: "GREY"),
    4: .same(proto: "OLIVE"),
    5: .same(proto: "GREEN"),
    6: .same(proto: "ORANGE"),
    7: .same(proto: "PINK"),
    8: .same(proto: "PURPLE"),
  ]
}

extension BackupProtos_AccountData.AccountSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_AccountData.protoMessageName + ".AccountSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readReceipts"),
    2: .same(proto: "sealedSenderIndicators"),
    3: .same(proto: "typingIndicators"),
    4: .same(proto: "noteToSelfMarkedUnread"),
    5: .same(proto: "linkPreviews"),
    6: .same(proto: "unlistedPhoneeumber"),
    7: .same(proto: "preferContactAvatars"),
    8: .same(proto: "universalExpireTimer"),
    9: .same(proto: "preferredReactionEmoji"),
    10: .same(proto: "displayBadgesOnProfile"),
    11: .same(proto: "keepMutedChatsArchived"),
    12: .same(proto: "myStoriesPrivacyHasBeenSet"),
    13: .same(proto: "onboardingStoryHasBeenViewed"),
    14: .same(proto: "storiesDisabled"),
    15: .same(proto: "storyViewReceiptsEnabled"),
    16: .same(proto: "groupStoryEducationSheetHasBeenSeen"),
    17: .same(proto: "usernameOnboardingHasBeenCompleted"),
    18: .same(proto: "phoneNumberSharingMode"),
  ]

  fileprivate class _StorageClass {
    var _readReceipts: Bool? = nil
    var _sealedSenderIndicators: Bool? = nil
    var _typingIndicators: Bool? = nil
    var _noteToSelfMarkedUnread: Bool? = nil
    var _linkPreviews: Bool? = nil
    var _unlistedPhoneeumber: Bool? = nil
    var _preferContactAvatars: Bool? = nil
    var _universalExpireTimer: UInt32? = nil
    var _preferredReactionEmoji: [String] = []
    var _displayBadgesOnProfile: Bool? = nil
    var _keepMutedChatsArchived: Bool? = nil
    var _myStoriesPrivacyHasBeenSet: Bool? = nil
    var _onboardingStoryHasBeenViewed: Bool? = nil
    var _storiesDisabled: Bool? = nil
    var _storyViewReceiptsEnabled: Bool? = nil
    var _groupStoryEducationSheetHasBeenSeen: Bool? = nil
    var _usernameOnboardingHasBeenCompleted: Bool? = nil
    var _phoneNumberSharingMode: BackupProtos_AccountData.PhoneNumberSharingMode? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _readReceipts = source._readReceipts
      _sealedSenderIndicators = source._sealedSenderIndicators
      _typingIndicators = source._typingIndicators
      _noteToSelfMarkedUnread = source._noteToSelfMarkedUnread
      _linkPreviews = source._linkPreviews
      _unlistedPhoneeumber = source._unlistedPhoneeumber
      _preferContactAvatars = source._preferContactAvatars
      _universalExpireTimer = source._universalExpireTimer
      _preferredReactionEmoji = source._preferredReactionEmoji
      _displayBadgesOnProfile = source._displayBadgesOnProfile
      _keepMutedChatsArchived = source._keepMutedChatsArchived
      _myStoriesPrivacyHasBeenSet = source._myStoriesPrivacyHasBeenSet
      _onboardingStoryHasBeenViewed = source._onboardingStoryHasBeenViewed
      _storiesDisabled = source._storiesDisabled
      _storyViewReceiptsEnabled = source._storyViewReceiptsEnabled
      _groupStoryEducationSheetHasBeenSeen = source._groupStoryEducationSheetHasBeenSeen
      _usernameOnboardingHasBeenCompleted = source._usernameOnboardingHasBeenCompleted
      _phoneNumberSharingMode = source._phoneNumberSharingMode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._readReceipts) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._sealedSenderIndicators) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._typingIndicators) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._noteToSelfMarkedUnread) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._linkPreviews) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._unlistedPhoneeumber) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._preferContactAvatars) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._universalExpireTimer) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._preferredReactionEmoji) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._displayBadgesOnProfile) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._keepMutedChatsArchived) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._myStoriesPrivacyHasBeenSet) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._onboardingStoryHasBeenViewed) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._storiesDisabled) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._storyViewReceiptsEnabled) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._groupStoryEducationSheetHasBeenSeen) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._usernameOnboardingHasBeenCompleted) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._phoneNumberSharingMode) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._readReceipts {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._sealedSenderIndicators {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._typingIndicators {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._noteToSelfMarkedUnread {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._linkPreviews {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._unlistedPhoneeumber {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._preferContactAvatars {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._universalExpireTimer {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      if !_storage._preferredReactionEmoji.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._preferredReactionEmoji, fieldNumber: 9)
      }
      try { if let v = _storage._displayBadgesOnProfile {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._keepMutedChatsArchived {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._myStoriesPrivacyHasBeenSet {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._onboardingStoryHasBeenViewed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._storiesDisabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._storyViewReceiptsEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._groupStoryEducationSheetHasBeenSeen {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._usernameOnboardingHasBeenCompleted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._phoneNumberSharingMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_AccountData.AccountSettings, rhs: BackupProtos_AccountData.AccountSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._readReceipts != rhs_storage._readReceipts {return false}
        if _storage._sealedSenderIndicators != rhs_storage._sealedSenderIndicators {return false}
        if _storage._typingIndicators != rhs_storage._typingIndicators {return false}
        if _storage._noteToSelfMarkedUnread != rhs_storage._noteToSelfMarkedUnread {return false}
        if _storage._linkPreviews != rhs_storage._linkPreviews {return false}
        if _storage._unlistedPhoneeumber != rhs_storage._unlistedPhoneeumber {return false}
        if _storage._preferContactAvatars != rhs_storage._preferContactAvatars {return false}
        if _storage._universalExpireTimer != rhs_storage._universalExpireTimer {return false}
        if _storage._preferredReactionEmoji != rhs_storage._preferredReactionEmoji {return false}
        if _storage._displayBadgesOnProfile != rhs_storage._displayBadgesOnProfile {return false}
        if _storage._keepMutedChatsArchived != rhs_storage._keepMutedChatsArchived {return false}
        if _storage._myStoriesPrivacyHasBeenSet != rhs_storage._myStoriesPrivacyHasBeenSet {return false}
        if _storage._onboardingStoryHasBeenViewed != rhs_storage._onboardingStoryHasBeenViewed {return false}
        if _storage._storiesDisabled != rhs_storage._storiesDisabled {return false}
        if _storage._storyViewReceiptsEnabled != rhs_storage._storyViewReceiptsEnabled {return false}
        if _storage._groupStoryEducationSheetHasBeenSeen != rhs_storage._groupStoryEducationSheetHasBeenSeen {return false}
        if _storage._usernameOnboardingHasBeenCompleted != rhs_storage._usernameOnboardingHasBeenCompleted {return false}
        if _storage._phoneNumberSharingMode != rhs_storage._phoneNumberSharingMode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Recipient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Recipient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "contact"),
    3: .same(proto: "group"),
    4: .same(proto: "distributionList"),
    5: .same(proto: "selfRecipient"),
    6: .same(proto: "releaseNotes"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64? = nil
    var _contact: BackupProtos_Contact? = nil
    var _group: BackupProtos_Group? = nil
    var _distributionList: BackupProtos_DistributionList? = nil
    var _selfRecipient: BackupProtos_SelfRecipient? = nil
    var _releaseNotes: BackupProtos_ReleaseNotes? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _contact = source._contact
      _group = source._group
      _distributionList = source._distributionList
      _selfRecipient = source._selfRecipient
      _releaseNotes = source._releaseNotes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._contact) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._distributionList) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._selfRecipient) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._releaseNotes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._contact {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._distributionList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._selfRecipient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._releaseNotes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Recipient, rhs: BackupProtos_Recipient) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._contact != rhs_storage._contact {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._distributionList != rhs_storage._distributionList {return false}
        if _storage._selfRecipient != rhs_storage._selfRecipient {return false}
        if _storage._releaseNotes != rhs_storage._releaseNotes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aci"),
    2: .same(proto: "pni"),
    3: .same(proto: "username"),
    4: .same(proto: "e164"),
    5: .same(proto: "blocked"),
    6: .same(proto: "hidden"),
    7: .same(proto: "registered"),
    8: .same(proto: "unregisteredTimestamp"),
    9: .same(proto: "profileKey"),
    10: .same(proto: "profileSharing"),
    11: .same(proto: "profileGivenName"),
    12: .same(proto: "profileFamilyName"),
    13: .same(proto: "hideStory"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._aci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._pni) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._e164) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._blocked) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._hidden) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._registered) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._unregisteredTimestamp) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._profileKey) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._profileSharing) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._profileGivenName) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._profileFamilyName) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self._hideStory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._aci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pni {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._e164 {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._blocked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._hidden {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._registered {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._unregisteredTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._profileKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._profileSharing {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._profileGivenName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._profileFamilyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._hideStory {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Contact, rhs: BackupProtos_Contact) -> Bool {
    if lhs._aci != rhs._aci {return false}
    if lhs._pni != rhs._pni {return false}
    if lhs._username != rhs._username {return false}
    if lhs._e164 != rhs._e164 {return false}
    if lhs._blocked != rhs._blocked {return false}
    if lhs._hidden != rhs._hidden {return false}
    if lhs._registered != rhs._registered {return false}
    if lhs._unregisteredTimestamp != rhs._unregisteredTimestamp {return false}
    if lhs._profileKey != rhs._profileKey {return false}
    if lhs._profileSharing != rhs._profileSharing {return false}
    if lhs._profileGivenName != rhs._profileGivenName {return false}
    if lhs._profileFamilyName != rhs._profileFamilyName {return false}
    if lhs._hideStory != rhs._hideStory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Contact.Registered: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "REGISTERED"),
    2: .same(proto: "NOT_REGISTERED"),
  ]
}

extension BackupProtos_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "masterKey"),
    2: .same(proto: "whitelisted"),
    3: .same(proto: "hideStory"),
    4: .same(proto: "storySendMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._masterKey) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._whitelisted) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._hideStory) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._storySendMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._masterKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._whitelisted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hideStory {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._storySendMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Group, rhs: BackupProtos_Group) -> Bool {
    if lhs._masterKey != rhs._masterKey {return false}
    if lhs._whitelisted != rhs._whitelisted {return false}
    if lhs._hideStory != rhs._hideStory {return false}
    if lhs._storySendMode != rhs._storySendMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Group.StorySendMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "DISABLED"),
    2: .same(proto: "ENABLED"),
  ]
}

extension BackupProtos_SelfRecipient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelfRecipient"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SelfRecipient, rhs: BackupProtos_SelfRecipient) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ReleaseNotes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseNotes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ReleaseNotes, rhs: BackupProtos_ReleaseNotes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Chat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Chat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "recipientId"),
    3: .same(proto: "archived"),
    4: .same(proto: "pinnedOrder"),
    5: .same(proto: "expirationTimerMs"),
    6: .same(proto: "muteUntilMs"),
    7: .same(proto: "markedUnread"),
    8: .same(proto: "dontNotifyForMentionsIfMuted"),
    9: .same(proto: "wallpaper"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._recipientID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._archived) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._pinnedOrder) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._expirationTimerMs) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._muteUntilMs) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._markedUnread) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._dontNotifyForMentionsIfMuted) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._wallpaper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._archived {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pinnedOrder {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expirationTimerMs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._muteUntilMs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._markedUnread {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._dontNotifyForMentionsIfMuted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._wallpaper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Chat, rhs: BackupProtos_Chat) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._recipientID != rhs._recipientID {return false}
    if lhs._archived != rhs._archived {return false}
    if lhs._pinnedOrder != rhs._pinnedOrder {return false}
    if lhs._expirationTimerMs != rhs._expirationTimerMs {return false}
    if lhs._muteUntilMs != rhs._muteUntilMs {return false}
    if lhs._markedUnread != rhs._markedUnread {return false}
    if lhs._dontNotifyForMentionsIfMuted != rhs._dontNotifyForMentionsIfMuted {return false}
    if lhs._wallpaper != rhs._wallpaper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_DistributionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DistributionList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "distributionId"),
    3: .same(proto: "allowReplies"),
    4: .same(proto: "deletionTimestamp"),
    5: .same(proto: "privacyMode"),
    6: .same(proto: "memberRecipientIds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._distributionID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._allowReplies) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._deletionTimestamp) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._privacyMode) }()
      case 6: try { try decoder.decodeRepeatedUInt64Field(value: &self.memberRecipientIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._distributionID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._allowReplies {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._deletionTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._privacyMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    if !self.memberRecipientIds.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.memberRecipientIds, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_DistributionList, rhs: BackupProtos_DistributionList) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._distributionID != rhs._distributionID {return false}
    if lhs._allowReplies != rhs._allowReplies {return false}
    if lhs._deletionTimestamp != rhs._deletionTimestamp {return false}
    if lhs._privacyMode != rhs._privacyMode {return false}
    if lhs.memberRecipientIds != rhs.memberRecipientIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_DistributionList.PrivacyMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ONLY_WITH"),
    2: .same(proto: "ALL_EXCEPT"),
    3: .same(proto: "ALL"),
  ]
}

extension BackupProtos_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Identity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceId"),
    2: .same(proto: "identityKey"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "firstUse"),
    5: .same(proto: "verified"),
    6: .same(proto: "nonblockingApproval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._serviceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._identityKey) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._firstUse) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._verified) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._nonblockingApproval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identityKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._firstUse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._verified {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nonblockingApproval {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Identity, rhs: BackupProtos_Identity) -> Bool {
    if lhs._serviceID != rhs._serviceID {return false}
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._firstUse != rhs._firstUse {return false}
    if lhs._verified != rhs._verified {return false}
    if lhs._nonblockingApproval != rhs._nonblockingApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "conversationRecipientId"),
    3: .same(proto: "type"),
    4: .same(proto: "outgoing"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "ringerRecipientId"),
    7: .same(proto: "event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._callID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._conversationRecipientID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._outgoing) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._ringerRecipientID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._event) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._conversationRecipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._outgoing {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._ringerRecipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Call, rhs: BackupProtos_Call) -> Bool {
    if lhs._callID != rhs._callID {return false}
    if lhs._conversationRecipientID != rhs._conversationRecipientID {return false}
    if lhs._type != rhs._type {return false}
    if lhs._outgoing != rhs._outgoing {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._ringerRecipientID != rhs._ringerRecipientID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Call.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "AUDIO_CALL"),
    2: .same(proto: "VIDEO_CALL"),
    3: .same(proto: "GROUP_CALL"),
    4: .same(proto: "AD_HOC_CALL"),
  ]
}

extension BackupProtos_Call.Event: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_EVENT"),
    1: .same(proto: "OUTGOING"),
    2: .same(proto: "ACCEPTED"),
    3: .same(proto: "NOT_ACCEPTED"),
    4: .same(proto: "MISSED"),
    5: .same(proto: "DELETE"),
    6: .same(proto: "GENERIC_GROUP_CALL"),
    7: .same(proto: "JOINED"),
    8: .same(proto: "DECLINED"),
    9: .same(proto: "OUTGOING_RING"),
  ]
}

extension BackupProtos_ChatItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chatId"),
    2: .same(proto: "authorId"),
    3: .same(proto: "dateSent"),
    4: .same(proto: "expireStartMs"),
    5: .same(proto: "expiresInMs"),
    6: .same(proto: "revisions"),
    7: .same(proto: "sms"),
    8: .same(proto: "incoming"),
    9: .same(proto: "outgoing"),
    10: .same(proto: "standardMessage"),
    11: .same(proto: "contactMessage"),
    12: .same(proto: "voiceMessage"),
    13: .same(proto: "stickerMessage"),
    14: .same(proto: "remoteDeletedMessage"),
    15: .same(proto: "updateMessage"),
  ]

  fileprivate class _StorageClass {
    var _chatID: UInt64? = nil
    var _authorID: UInt64? = nil
    var _dateSent: UInt64? = nil
    var _expireStartMs: UInt64? = nil
    var _expiresInMs: UInt64? = nil
    var _revisions: [BackupProtos_ChatItem] = []
    var _sms: Bool? = nil
    var _incoming: BackupProtos_ChatItem.IncomingMessageDetails? = nil
    var _outgoing: BackupProtos_ChatItem.OutgoingMessageDetails? = nil
    var _standardMessage: BackupProtos_StandardMessage? = nil
    var _contactMessage: BackupProtos_ContactMessage? = nil
    var _voiceMessage: BackupProtos_VoiceMessage? = nil
    var _stickerMessage: BackupProtos_StickerMessage? = nil
    var _remoteDeletedMessage: BackupProtos_RemoteDeletedMessage? = nil
    var _updateMessage: BackupProtos_UpdateMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chatID = source._chatID
      _authorID = source._authorID
      _dateSent = source._dateSent
      _expireStartMs = source._expireStartMs
      _expiresInMs = source._expiresInMs
      _revisions = source._revisions
      _sms = source._sms
      _incoming = source._incoming
      _outgoing = source._outgoing
      _standardMessage = source._standardMessage
      _contactMessage = source._contactMessage
      _voiceMessage = source._voiceMessage
      _stickerMessage = source._stickerMessage
      _remoteDeletedMessage = source._remoteDeletedMessage
      _updateMessage = source._updateMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._chatID) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._authorID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._dateSent) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._expireStartMs) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._expiresInMs) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._revisions) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._sms) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._incoming) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._outgoing) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._standardMessage) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._contactMessage) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._voiceMessage) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._stickerMessage) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._remoteDeletedMessage) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._updateMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._chatID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._authorID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dateSent {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._expireStartMs {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expiresInMs {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
      if !_storage._revisions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._revisions, fieldNumber: 6)
      }
      try { if let v = _storage._sms {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._incoming {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._outgoing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._standardMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._contactMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._voiceMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._stickerMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._remoteDeletedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._updateMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatItem, rhs: BackupProtos_ChatItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._authorID != rhs_storage._authorID {return false}
        if _storage._dateSent != rhs_storage._dateSent {return false}
        if _storage._expireStartMs != rhs_storage._expireStartMs {return false}
        if _storage._expiresInMs != rhs_storage._expiresInMs {return false}
        if _storage._revisions != rhs_storage._revisions {return false}
        if _storage._sms != rhs_storage._sms {return false}
        if _storage._incoming != rhs_storage._incoming {return false}
        if _storage._outgoing != rhs_storage._outgoing {return false}
        if _storage._standardMessage != rhs_storage._standardMessage {return false}
        if _storage._contactMessage != rhs_storage._contactMessage {return false}
        if _storage._voiceMessage != rhs_storage._voiceMessage {return false}
        if _storage._stickerMessage != rhs_storage._stickerMessage {return false}
        if _storage._remoteDeletedMessage != rhs_storage._remoteDeletedMessage {return false}
        if _storage._updateMessage != rhs_storage._updateMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ChatItem.IncomingMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ChatItem.protoMessageName + ".IncomingMessageDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dateReceived"),
    2: .same(proto: "dateServerSent"),
    3: .same(proto: "read"),
    4: .same(proto: "sealedSender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._dateReceived) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._dateServerSent) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._read) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._sealedSender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dateReceived {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dateServerSent {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._read {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._sealedSender {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatItem.IncomingMessageDetails, rhs: BackupProtos_ChatItem.IncomingMessageDetails) -> Bool {
    if lhs._dateReceived != rhs._dateReceived {return false}
    if lhs._dateServerSent != rhs._dateServerSent {return false}
    if lhs._read != rhs._read {return false}
    if lhs._sealedSender != rhs._sealedSender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ChatItem.OutgoingMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ChatItem.protoMessageName + ".OutgoingMessageDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sendStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sendStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sendStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sendStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatItem.OutgoingMessageDetails, rhs: BackupProtos_ChatItem.OutgoingMessageDetails) -> Bool {
    if lhs.sendStatus != rhs.sendStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SendStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipientId"),
    2: .same(proto: "deliveryStatus"),
    3: .same(proto: "networkFailure"),
    4: .same(proto: "identityKeyMismatch"),
    5: .same(proto: "sealedSender"),
    6: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._recipientID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._deliveryStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._networkFailure) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._identityKeyMismatch) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._sealedSender) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._deliveryStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._networkFailure {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._identityKeyMismatch {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._sealedSender {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SendStatus, rhs: BackupProtos_SendStatus) -> Bool {
    if lhs._recipientID != rhs._recipientID {return false}
    if lhs._deliveryStatus != rhs._deliveryStatus {return false}
    if lhs._networkFailure != rhs._networkFailure {return false}
    if lhs._identityKeyMismatch != rhs._identityKeyMismatch {return false}
    if lhs._sealedSender != rhs._sealedSender {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SendStatus.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "FAILED"),
    2: .same(proto: "PENDING"),
    3: .same(proto: "SENT"),
    4: .same(proto: "DELIVERED"),
    5: .same(proto: "READ"),
    6: .same(proto: "VIEWED"),
    7: .same(proto: "SKIPPED"),
  ]
}

extension BackupProtos_Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Text"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "bodyRanges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._body) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bodyRanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.bodyRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyRanges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Text, rhs: BackupProtos_Text) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.bodyRanges != rhs.bodyRanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StandardMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StandardMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quote"),
    2: .same(proto: "text"),
    3: .same(proto: "attachments"),
    4: .same(proto: "linkPreview"),
    5: .same(proto: "longText"),
    6: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._quote) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.linkPreview) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._longText) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._quote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 3)
    }
    if !self.linkPreview.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkPreview, fieldNumber: 4)
    }
    try { if let v = self._longText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StandardMessage, rhs: BackupProtos_StandardMessage) -> Bool {
    if lhs._quote != rhs._quote {return false}
    if lhs._text != rhs._text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.linkPreview != rhs.linkPreview {return false}
    if lhs._longText != rhs._longText {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    2: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.contact) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contact.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contact, fieldNumber: 1)
    }
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactMessage, rhs: BackupProtos_ContactMessage) -> Bool {
    if lhs.contact != rhs.contact {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "number"),
    4: .same(proto: "email"),
    5: .same(proto: "address"),
    6: .same(proto: "avatar"),
    7: .same(proto: "organization"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.number) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.email) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.address) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._organization) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.number.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.number, fieldNumber: 3)
    }
    if !self.email.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.email, fieldNumber: 4)
    }
    if !self.address.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.address, fieldNumber: 5)
    }
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._organization {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment, rhs: BackupProtos_ContactAttachment) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.number != rhs.number {return false}
    if lhs.email != rhs.email {return false}
    if lhs.address != rhs.address {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs._organization != rhs._organization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Name"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "givenName"),
    2: .same(proto: "familyName"),
    3: .same(proto: "prefix"),
    4: .same(proto: "suffix"),
    5: .same(proto: "middleName"),
    6: .same(proto: "displayName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._givenName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._familyName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._prefix) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._suffix) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._middleName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._givenName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._familyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._suffix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._middleName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Name, rhs: BackupProtos_ContactAttachment.Name) -> Bool {
    if lhs._givenName != rhs._givenName {return false}
    if lhs._familyName != rhs._familyName {return false}
    if lhs._prefix != rhs._prefix {return false}
    if lhs._suffix != rhs._suffix {return false}
    if lhs._middleName != rhs._middleName {return false}
    if lhs._displayName != rhs._displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Phone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Phone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Phone, rhs: BackupProtos_ContactAttachment.Phone) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Phone.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HOME"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "WORK"),
    4: .same(proto: "CUSTOM"),
  ]
}

extension BackupProtos_ContactAttachment.Email: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Email"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Email, rhs: BackupProtos_ContactAttachment.Email) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Email.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HOME"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "WORK"),
    4: .same(proto: "CUSTOM"),
  ]
}

extension BackupProtos_ContactAttachment.PostalAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".PostalAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "label"),
    3: .same(proto: "street"),
    4: .same(proto: "pobox"),
    5: .same(proto: "neighborhood"),
    6: .same(proto: "city"),
    7: .same(proto: "region"),
    8: .same(proto: "postcode"),
    9: .same(proto: "country"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._street) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._pobox) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._neighborhood) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._city) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._region) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._postcode) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._country) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._street {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pobox {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._neighborhood {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._city {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._region {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._postcode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._country {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.PostalAddress, rhs: BackupProtos_ContactAttachment.PostalAddress) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs._street != rhs._street {return false}
    if lhs._pobox != rhs._pobox {return false}
    if lhs._neighborhood != rhs._neighborhood {return false}
    if lhs._city != rhs._city {return false}
    if lhs._region != rhs._region {return false}
    if lhs._postcode != rhs._postcode {return false}
    if lhs._country != rhs._country {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.PostalAddress.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HOME"),
    2: .same(proto: "WORK"),
    3: .same(proto: "CUSTOM"),
  ]
}

extension BackupProtos_ContactAttachment.Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Avatar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Avatar, rhs: BackupProtos_ContactAttachment.Avatar) -> Bool {
    if lhs._avatar != rhs._avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_DocumentMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "document"),
    3: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_DocumentMessage, rhs: BackupProtos_DocumentMessage) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._document != rhs._document {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_VoiceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VoiceMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quote"),
    2: .same(proto: "audio"),
    3: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._quote) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._audio) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._quote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._audio {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_VoiceMessage, rhs: BackupProtos_VoiceMessage) -> Bool {
    if lhs._quote != rhs._quote {return false}
    if lhs._audio != rhs._audio {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StickerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StickerMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sticker"),
    2: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sticker) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sticker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StickerMessage, rhs: BackupProtos_StickerMessage) -> Bool {
    if lhs._sticker != rhs._sticker {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_RemoteDeletedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteDeletedMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_RemoteDeletedMessage, rhs: BackupProtos_RemoteDeletedMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ScheduledMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScheduledMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "scheduledTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._scheduledTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._scheduledTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ScheduledMessage, rhs: BackupProtos_ScheduledMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs._scheduledTime != rhs._scheduledTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Sticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packId"),
    2: .same(proto: "packKey"),
    3: .same(proto: "stickerId"),
    4: .same(proto: "emoji"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._packID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._packKey) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._stickerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._packID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._packKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stickerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Sticker, rhs: BackupProtos_Sticker) -> Bool {
    if lhs._packID != rhs._packID {return false}
    if lhs._packKey != rhs._packKey {return false}
    if lhs._stickerID != rhs._stickerID {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_LinkPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinkPreview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "image"),
    4: .same(proto: "descriptionText"),
    5: .same(proto: "date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._descriptionText) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._date) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._descriptionText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_LinkPreview, rhs: BackupProtos_LinkPreview) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._title != rhs._title {return false}
    if lhs._image != rhs._image {return false}
    if lhs._descriptionText != rhs._descriptionText {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_FilePointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilePointer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backupLocator"),
    2: .same(proto: "attachmentLocator"),
    3: .same(proto: "legacyAttachmentLocator"),
    4: .same(proto: "key"),
    5: .same(proto: "contentType"),
    6: .same(proto: "size"),
    7: .same(proto: "digest"),
    8: .same(proto: "incrementalMac"),
    9: .same(proto: "incrementalMacChunkSize"),
    10: .same(proto: "fileName"),
    11: .same(proto: "flags"),
    12: .same(proto: "width"),
    13: .same(proto: "height"),
    14: .same(proto: "caption"),
    15: .same(proto: "blurHash"),
  ]

  fileprivate class _StorageClass {
    var _backupLocator: BackupProtos_FilePointer.BackupLocator? = nil
    var _attachmentLocator: BackupProtos_FilePointer.AttachmentLocator? = nil
    var _legacyAttachmentLocator: BackupProtos_FilePointer.LegacyAttachmentLocator? = nil
    var _key: Data? = nil
    var _contentType: String? = nil
    var _size: UInt32? = nil
    var _digest: Data? = nil
    var _incrementalMac: Data? = nil
    var _incrementalMacChunkSize: Data? = nil
    var _fileName: String? = nil
    var _flags: UInt32? = nil
    var _width: UInt32? = nil
    var _height: UInt32? = nil
    var _caption: String? = nil
    var _blurHash: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _backupLocator = source._backupLocator
      _attachmentLocator = source._attachmentLocator
      _legacyAttachmentLocator = source._legacyAttachmentLocator
      _key = source._key
      _contentType = source._contentType
      _size = source._size
      _digest = source._digest
      _incrementalMac = source._incrementalMac
      _incrementalMacChunkSize = source._incrementalMacChunkSize
      _fileName = source._fileName
      _flags = source._flags
      _width = source._width
      _height = source._height
      _caption = source._caption
      _blurHash = source._blurHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._backupLocator) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._attachmentLocator) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._legacyAttachmentLocator) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._key) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._contentType) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._size) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._digest) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._incrementalMac) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._incrementalMacChunkSize) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._fileName) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._width) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._height) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._caption) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._blurHash) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._backupLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._attachmentLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._legacyAttachmentLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._key {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._contentType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._size {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._digest {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._incrementalMac {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._incrementalMacChunkSize {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._fileName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._flags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._width {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._height {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._caption {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._blurHash {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_FilePointer, rhs: BackupProtos_FilePointer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._backupLocator != rhs_storage._backupLocator {return false}
        if _storage._attachmentLocator != rhs_storage._attachmentLocator {return false}
        if _storage._legacyAttachmentLocator != rhs_storage._legacyAttachmentLocator {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._contentType != rhs_storage._contentType {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._digest != rhs_storage._digest {return false}
        if _storage._incrementalMac != rhs_storage._incrementalMac {return false}
        if _storage._incrementalMacChunkSize != rhs_storage._incrementalMacChunkSize {return false}
        if _storage._fileName != rhs_storage._fileName {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._caption != rhs_storage._caption {return false}
        if _storage._blurHash != rhs_storage._blurHash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_FilePointer.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOICE_MESSAGE"),
    1: .same(proto: "BORDERLESS"),
    2: .same(proto: "GIF"),
  ]
}

extension BackupProtos_FilePointer.BackupLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_FilePointer.protoMessageName + ".BackupLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mediaName"),
    2: .same(proto: "cdnNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mediaName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._cdnNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mediaName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cdnNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_FilePointer.BackupLocator, rhs: BackupProtos_FilePointer.BackupLocator) -> Bool {
    if lhs._mediaName != rhs._mediaName {return false}
    if lhs._cdnNumber != rhs._cdnNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_FilePointer.AttachmentLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_FilePointer.protoMessageName + ".AttachmentLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cdnKey"),
    2: .same(proto: "cdnNumber"),
    3: .same(proto: "uploadTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._cdnKey) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._cdnNumber) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._uploadTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cdnKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cdnNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._uploadTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_FilePointer.AttachmentLocator, rhs: BackupProtos_FilePointer.AttachmentLocator) -> Bool {
    if lhs._cdnKey != rhs._cdnKey {return false}
    if lhs._cdnNumber != rhs._cdnNumber {return false}
    if lhs._uploadTimestamp != rhs._uploadTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_FilePointer.LegacyAttachmentLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_FilePointer.protoMessageName + ".LegacyAttachmentLocator"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_FilePointer.LegacyAttachmentLocator, rhs: BackupProtos_FilePointer.LegacyAttachmentLocator) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Quote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetSentTimestamp"),
    2: .same(proto: "authorId"),
    3: .same(proto: "text"),
    4: .same(proto: "attachments"),
    5: .same(proto: "bodyRanges"),
    6: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._targetSentTimestamp) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._authorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.bodyRanges) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._targetSentTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authorID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 4)
    }
    if !self.bodyRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyRanges, fieldNumber: 5)
    }
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Quote, rhs: BackupProtos_Quote) -> Bool {
    if lhs._targetSentTimestamp != rhs._targetSentTimestamp {return false}
    if lhs._authorID != rhs._authorID {return false}
    if lhs._text != rhs._text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.bodyRanges != rhs.bodyRanges {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Quote.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NORMAL"),
    2: .same(proto: "GIFTBADGE"),
  ]
}

extension BackupProtos_Quote.QuotedAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_Quote.protoMessageName + ".QuotedAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "fileName"),
    3: .same(proto: "thumbnail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._thumbnail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._thumbnail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Quote.QuotedAttachment, rhs: BackupProtos_Quote.QuotedAttachment) -> Bool {
    if lhs._contentType != rhs._contentType {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_BodyRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BodyRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "length"),
    3: .same(proto: "mentionAci"),
    4: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mentionAci) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._style) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mentionAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_BodyRange, rhs: BackupProtos_BodyRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._length != rhs._length {return false}
    if lhs._mentionAci != rhs._mentionAci {return false}
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_BodyRange.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "BOLD"),
    2: .same(proto: "ITALIC"),
    3: .same(proto: "SPOILER"),
    4: .same(proto: "STRIKETHROUGH"),
    5: .same(proto: "MONOSPACE"),
  ]
}

extension BackupProtos_Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .same(proto: "authorId"),
    3: .same(proto: "sentTimestamp"),
    4: .same(proto: "receivedTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._authorID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._sentTimestamp) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._receivedTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authorID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sentTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._receivedTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Reaction, rhs: BackupProtos_Reaction) -> Bool {
    if lhs._emoji != rhs._emoji {return false}
    if lhs._authorID != rhs._authorID {return false}
    if lhs._sentTimestamp != rhs._sentTimestamp {return false}
    if lhs._receivedTimestamp != rhs._receivedTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_UpdateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "simpleUpdate"),
    2: .same(proto: "groupDescription"),
    3: .same(proto: "expirationTimerChange"),
    4: .same(proto: "profileChange"),
    5: .same(proto: "threadMerge"),
    6: .same(proto: "sessionSwitchover"),
    7: .same(proto: "callingMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._simpleUpdate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._groupDescription) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expirationTimerChange) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._profileChange) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._threadMerge) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sessionSwitchover) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._callingMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._simpleUpdate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupDescription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._expirationTimerChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._profileChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._threadMerge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._sessionSwitchover {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._callingMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_UpdateMessage, rhs: BackupProtos_UpdateMessage) -> Bool {
    if lhs._simpleUpdate != rhs._simpleUpdate {return false}
    if lhs._groupDescription != rhs._groupDescription {return false}
    if lhs._expirationTimerChange != rhs._expirationTimerChange {return false}
    if lhs._profileChange != rhs._profileChange {return false}
    if lhs._threadMerge != rhs._threadMerge {return false}
    if lhs._sessionSwitchover != rhs._sessionSwitchover {return false}
    if lhs._callingMessage != rhs._callingMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_CallingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "callMessage"),
    3: .same(proto: "groupCall"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._callID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._callMessage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._groupCall) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._callMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupCall {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_CallingMessage, rhs: BackupProtos_CallingMessage) -> Bool {
    if lhs._callID != rhs._callID {return false}
    if lhs._callMessage != rhs._callMessage {return false}
    if lhs._groupCall != rhs._groupCall {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_CallMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_CallMessage, rhs: BackupProtos_CallMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_CallMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INCOMING_AUDIO_CALL"),
    2: .same(proto: "INCOMING_VIDEO_CALL"),
    3: .same(proto: "OUTGOING_AUDIO_CALL"),
    4: .same(proto: "OUTGOING_VIDEO_CALL"),
    5: .same(proto: "MISSED_AUDIO_CALL"),
    6: .same(proto: "MISSED_VIDEO_CALL"),
  ]
}

extension BackupProtos_GroupCallMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupCallMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startedCallAci"),
    2: .same(proto: "startedCallTimestamp"),
    3: .same(proto: "inCallAcis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._startedCallAci) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._startedCallTimestamp) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.inCallAcis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startedCallAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startedCallTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.inCallAcis.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.inCallAcis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupCallMessage, rhs: BackupProtos_GroupCallMessage) -> Bool {
    if lhs._startedCallAci != rhs._startedCallAci {return false}
    if lhs._startedCallTimestamp != rhs._startedCallTimestamp {return false}
    if lhs.inCallAcis != rhs.inCallAcis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SimpleUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimpleUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SimpleUpdate, rhs: BackupProtos_SimpleUpdate) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SimpleUpdate.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "JOINED_SIGNAL"),
    2: .same(proto: "IDENTITY_UPDATE"),
    3: .same(proto: "IDENTITY_VERIFIED"),
    4: .same(proto: "IDENTITY_DEFAULT"),
    5: .same(proto: "CHANGE_NUMBER"),
    6: .same(proto: "BOOST_REQUEST"),
    7: .same(proto: "END_SESSION"),
    8: .same(proto: "CHAT_SESSION_REFRESH"),
    9: .same(proto: "BAD_DECRYPT"),
    10: .same(proto: "PAYMENTS_ACTIVATED"),
    11: .same(proto: "PAYMENT_ACTIVATION_REQUEST"),
  ]
}

extension BackupProtos_GroupDescriptionUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupDescriptionUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newDescription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._newDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupDescriptionUpdate, rhs: BackupProtos_GroupDescriptionUpdate) -> Bool {
    if lhs._newDescription != rhs._newDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ExpirationTimerChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpirationTimerChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiresInMs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._expiresInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expiresInMs {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ExpirationTimerChange, rhs: BackupProtos_ExpirationTimerChange) -> Bool {
    if lhs._expiresInMs != rhs._expiresInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ProfileChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProfileChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousName"),
    2: .same(proto: "newName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._previousName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._newName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._previousName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ProfileChange, rhs: BackupProtos_ProfileChange) -> Bool {
    if lhs._previousName != rhs._previousName {return false}
    if lhs._newName != rhs._newName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ThreadMergeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThreadMergeEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousE164"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._previousE164) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._previousE164 {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ThreadMergeEvent, rhs: BackupProtos_ThreadMergeEvent) -> Bool {
    if lhs._previousE164 != rhs._previousE164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SessionSwitchoverEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionSwitchoverEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "e164"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._e164) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._e164 {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SessionSwitchoverEvent, rhs: BackupProtos_SessionSwitchoverEvent) -> Bool {
    if lhs._e164 != rhs._e164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StickerPack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StickerPack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
    3: .same(proto: "title"),
    4: .same(proto: "author"),
    5: .same(proto: "stickers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.stickers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.stickers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stickers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StickerPack, rhs: BackupProtos_StickerPack) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._key != rhs._key {return false}
    if lhs._title != rhs._title {return false}
    if lhs._author != rhs._author {return false}
    if lhs.stickers != rhs.stickers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StickerPackSticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StickerPackSticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "emoji"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StickerPackSticker, rhs: BackupProtos_StickerPackSticker) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
