//
// Copyright 2023 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Backup.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2014 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only

/// iOS - since we use a modern proto-compiler, we must specify
/// the legacy proto format.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct BackupProtos_BackupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var version: UInt64 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  /// @required
  var backupTime: UInt64 {
    get {return _backupTime ?? 0}
    set {_backupTime = newValue}
  }
  /// Returns true if `backupTime` has been explicitly set.
  var hasBackupTime: Bool {return self._backupTime != nil}
  /// Clears the value of `backupTime`. Subsequent reads from it will return its default value.
  mutating func clearBackupTime() {self._backupTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: UInt64? = nil
  fileprivate var _backupTime: UInt64? = nil
}

struct BackupProtos_Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof item {
  var account: BackupProtos_AccountData {
    get {return _storage._account ?? BackupProtos_AccountData()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  var recipient: BackupProtos_Recipient {
    get {return _storage._recipient ?? BackupProtos_Recipient()}
    set {_uniqueStorage()._recipient = newValue}
  }
  /// Returns true if `recipient` has been explicitly set.
  var hasRecipient: Bool {return _storage._recipient != nil}
  /// Clears the value of `recipient`. Subsequent reads from it will return its default value.
  mutating func clearRecipient() {_uniqueStorage()._recipient = nil}

  var chat: BackupProtos_Chat {
    get {return _storage._chat ?? BackupProtos_Chat()}
    set {_uniqueStorage()._chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  var hasChat: Bool {return _storage._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  mutating func clearChat() {_uniqueStorage()._chat = nil}

  var chatItem: BackupProtos_ChatItem {
    get {return _storage._chatItem ?? BackupProtos_ChatItem()}
    set {_uniqueStorage()._chatItem = newValue}
  }
  /// Returns true if `chatItem` has been explicitly set.
  var hasChatItem: Bool {return _storage._chatItem != nil}
  /// Clears the value of `chatItem`. Subsequent reads from it will return its default value.
  mutating func clearChatItem() {_uniqueStorage()._chatItem = nil}

  var call: BackupProtos_Call {
    get {return _storage._call ?? BackupProtos_Call()}
    set {_uniqueStorage()._call = newValue}
  }
  /// Returns true if `call` has been explicitly set.
  var hasCall: Bool {return _storage._call != nil}
  /// Clears the value of `call`. Subsequent reads from it will return its default value.
  mutating func clearCall() {_uniqueStorage()._call = nil}

  /// }
  var stickerPack: BackupProtos_StickerPack {
    get {return _storage._stickerPack ?? BackupProtos_StickerPack()}
    set {_uniqueStorage()._stickerPack = newValue}
  }
  /// Returns true if `stickerPack` has been explicitly set.
  var hasStickerPack: Bool {return _storage._stickerPack != nil}
  /// Clears the value of `stickerPack`. Subsequent reads from it will return its default value.
  mutating func clearStickerPack() {_uniqueStorage()._stickerPack = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_AccountData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var aciIdentityPublicKey: Data {
    get {return _storage._aciIdentityPublicKey ?? Data()}
    set {_uniqueStorage()._aciIdentityPublicKey = newValue}
  }
  /// Returns true if `aciIdentityPublicKey` has been explicitly set.
  var hasAciIdentityPublicKey: Bool {return _storage._aciIdentityPublicKey != nil}
  /// Clears the value of `aciIdentityPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearAciIdentityPublicKey() {_uniqueStorage()._aciIdentityPublicKey = nil}

  /// @required
  var aciIdentityPrivateKey: Data {
    get {return _storage._aciIdentityPrivateKey ?? Data()}
    set {_uniqueStorage()._aciIdentityPrivateKey = newValue}
  }
  /// Returns true if `aciIdentityPrivateKey` has been explicitly set.
  var hasAciIdentityPrivateKey: Bool {return _storage._aciIdentityPrivateKey != nil}
  /// Clears the value of `aciIdentityPrivateKey`. Subsequent reads from it will return its default value.
  mutating func clearAciIdentityPrivateKey() {_uniqueStorage()._aciIdentityPrivateKey = nil}

  /// @required
  var pniIdentityPublicKey: Data {
    get {return _storage._pniIdentityPublicKey ?? Data()}
    set {_uniqueStorage()._pniIdentityPublicKey = newValue}
  }
  /// Returns true if `pniIdentityPublicKey` has been explicitly set.
  var hasPniIdentityPublicKey: Bool {return _storage._pniIdentityPublicKey != nil}
  /// Clears the value of `pniIdentityPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearPniIdentityPublicKey() {_uniqueStorage()._pniIdentityPublicKey = nil}

  /// @required
  var pniIdentityPrivateKey: Data {
    get {return _storage._pniIdentityPrivateKey ?? Data()}
    set {_uniqueStorage()._pniIdentityPrivateKey = newValue}
  }
  /// Returns true if `pniIdentityPrivateKey` has been explicitly set.
  var hasPniIdentityPrivateKey: Bool {return _storage._pniIdentityPrivateKey != nil}
  /// Clears the value of `pniIdentityPrivateKey`. Subsequent reads from it will return its default value.
  mutating func clearPniIdentityPrivateKey() {_uniqueStorage()._pniIdentityPrivateKey = nil}

  /// @required
  var profileKey: Data {
    get {return _storage._profileKey ?? Data()}
    set {_uniqueStorage()._profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return _storage._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {_uniqueStorage()._profileKey = nil}

  var username: String {
    get {return _storage._username ?? String()}
    set {_uniqueStorage()._username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return _storage._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {_uniqueStorage()._username = nil}

  /// @required
  var usernameLink: BackupProtos_AccountData.UsernameLink {
    get {return _storage._usernameLink ?? BackupProtos_AccountData.UsernameLink()}
    set {_uniqueStorage()._usernameLink = newValue}
  }
  /// Returns true if `usernameLink` has been explicitly set.
  var hasUsernameLink: Bool {return _storage._usernameLink != nil}
  /// Clears the value of `usernameLink`. Subsequent reads from it will return its default value.
  mutating func clearUsernameLink() {_uniqueStorage()._usernameLink = nil}

  /// @required
  var givenName: String {
    get {return _storage._givenName ?? String()}
    set {_uniqueStorage()._givenName = newValue}
  }
  /// Returns true if `givenName` has been explicitly set.
  var hasGivenName: Bool {return _storage._givenName != nil}
  /// Clears the value of `givenName`. Subsequent reads from it will return its default value.
  mutating func clearGivenName() {_uniqueStorage()._givenName = nil}

  /// @required
  var familyName: String {
    get {return _storage._familyName ?? String()}
    set {_uniqueStorage()._familyName = newValue}
  }
  /// Returns true if `familyName` has been explicitly set.
  var hasFamilyName: Bool {return _storage._familyName != nil}
  /// Clears the value of `familyName`. Subsequent reads from it will return its default value.
  mutating func clearFamilyName() {_uniqueStorage()._familyName = nil}

  /// @required
  var avatarPath: String {
    get {return _storage._avatarPath ?? String()}
    set {_uniqueStorage()._avatarPath = newValue}
  }
  /// Returns true if `avatarPath` has been explicitly set.
  var hasAvatarPath: Bool {return _storage._avatarPath != nil}
  /// Clears the value of `avatarPath`. Subsequent reads from it will return its default value.
  mutating func clearAvatarPath() {_uniqueStorage()._avatarPath = nil}

  /// @required
  var subscriberID: Data {
    get {return _storage._subscriberID ?? Data()}
    set {_uniqueStorage()._subscriberID = newValue}
  }
  /// Returns true if `subscriberID` has been explicitly set.
  var hasSubscriberID: Bool {return _storage._subscriberID != nil}
  /// Clears the value of `subscriberID`. Subsequent reads from it will return its default value.
  mutating func clearSubscriberID() {_uniqueStorage()._subscriberID = nil}

  /// @required
  var subscriberCurrencyCode: String {
    get {return _storage._subscriberCurrencyCode ?? String()}
    set {_uniqueStorage()._subscriberCurrencyCode = newValue}
  }
  /// Returns true if `subscriberCurrencyCode` has been explicitly set.
  var hasSubscriberCurrencyCode: Bool {return _storage._subscriberCurrencyCode != nil}
  /// Clears the value of `subscriberCurrencyCode`. Subsequent reads from it will return its default value.
  mutating func clearSubscriberCurrencyCode() {_uniqueStorage()._subscriberCurrencyCode = nil}

  /// @required
  var subscriptionManuallyCancelled: Bool {
    get {return _storage._subscriptionManuallyCancelled ?? false}
    set {_uniqueStorage()._subscriptionManuallyCancelled = newValue}
  }
  /// Returns true if `subscriptionManuallyCancelled` has been explicitly set.
  var hasSubscriptionManuallyCancelled: Bool {return _storage._subscriptionManuallyCancelled != nil}
  /// Clears the value of `subscriptionManuallyCancelled`. Subsequent reads from it will return its default value.
  mutating func clearSubscriptionManuallyCancelled() {_uniqueStorage()._subscriptionManuallyCancelled = nil}

  /// @required
  var accountSettings: BackupProtos_AccountData.AccountSettings {
    get {return _storage._accountSettings ?? BackupProtos_AccountData.AccountSettings()}
    set {_uniqueStorage()._accountSettings = newValue}
  }
  /// Returns true if `accountSettings` has been explicitly set.
  var hasAccountSettings: Bool {return _storage._accountSettings != nil}
  /// Clears the value of `accountSettings`. Subsequent reads from it will return its default value.
  mutating func clearAccountSettings() {_uniqueStorage()._accountSettings = nil}

  /// @required
  var aci: Data {
    get {return _storage._aci ?? Data()}
    set {_uniqueStorage()._aci = newValue}
  }
  /// Returns true if `aci` has been explicitly set.
  var hasAci: Bool {return _storage._aci != nil}
  /// Clears the value of `aci`. Subsequent reads from it will return its default value.
  mutating func clearAci() {_uniqueStorage()._aci = nil}

  /// @required
  var pni: Data {
    get {return _storage._pni ?? Data()}
    set {_uniqueStorage()._pni = newValue}
  }
  /// Returns true if `pni` has been explicitly set.
  var hasPni: Bool {return _storage._pni != nil}
  /// Clears the value of `pni`. Subsequent reads from it will return its default value.
  mutating func clearPni() {_uniqueStorage()._pni = nil}

  /// @required
  var e164: UInt64 {
    get {return _storage._e164 ?? 0}
    set {_uniqueStorage()._e164 = newValue}
  }
  /// Returns true if `e164` has been explicitly set.
  var hasE164: Bool {return _storage._e164 != nil}
  /// Clears the value of `e164`. Subsequent reads from it will return its default value.
  mutating func clearE164() {_uniqueStorage()._e164 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PhoneNumberSharingMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case everybody // = 0
    case contactsOnly // = 1
    case nobody // = 2

    init() {
      self = .everybody
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .everybody
      case 1: self = .contactsOnly
      case 2: self = .nobody
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .everybody: return 0
      case .contactsOnly: return 1
      case .nobody: return 2
      }
    }

  }

  struct UsernameLink {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var entropy: Data {
      get {return _entropy ?? Data()}
      set {_entropy = newValue}
    }
    /// Returns true if `entropy` has been explicitly set.
    var hasEntropy: Bool {return self._entropy != nil}
    /// Clears the value of `entropy`. Subsequent reads from it will return its default value.
    mutating func clearEntropy() {self._entropy = nil}

    /// @required
    var serverID: Data {
      get {return _serverID ?? Data()}
      set {_serverID = newValue}
    }
    /// Returns true if `serverID` has been explicitly set.
    var hasServerID: Bool {return self._serverID != nil}
    /// Clears the value of `serverID`. Subsequent reads from it will return its default value.
    mutating func clearServerID() {self._serverID = nil}

    var color: BackupProtos_AccountData.UsernameLink.Color {
      get {return _color ?? .unknown}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Color: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case blue // = 1
      case white // = 2
      case grey // = 3
      case olive // = 4
      case green // = 5
      case orange // = 6
      case pink // = 7
      case purple // = 8

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .blue
        case 2: self = .white
        case 3: self = .grey
        case 4: self = .olive
        case 5: self = .green
        case 6: self = .orange
        case 7: self = .pink
        case 8: self = .purple
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .blue: return 1
        case .white: return 2
        case .grey: return 3
        case .olive: return 4
        case .green: return 5
        case .orange: return 6
        case .pink: return 7
        case .purple: return 8
        }
      }

    }

    init() {}

    fileprivate var _entropy: Data? = nil
    fileprivate var _serverID: Data? = nil
    fileprivate var _color: BackupProtos_AccountData.UsernameLink.Color? = nil
  }

  struct AccountSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var noteToSelfArchived: Bool {
      get {return _storage._noteToSelfArchived ?? false}
      set {_uniqueStorage()._noteToSelfArchived = newValue}
    }
    /// Returns true if `noteToSelfArchived` has been explicitly set.
    var hasNoteToSelfArchived: Bool {return _storage._noteToSelfArchived != nil}
    /// Clears the value of `noteToSelfArchived`. Subsequent reads from it will return its default value.
    mutating func clearNoteToSelfArchived() {_uniqueStorage()._noteToSelfArchived = nil}

    /// @required
    var readReceipts: Bool {
      get {return _storage._readReceipts ?? false}
      set {_uniqueStorage()._readReceipts = newValue}
    }
    /// Returns true if `readReceipts` has been explicitly set.
    var hasReadReceipts: Bool {return _storage._readReceipts != nil}
    /// Clears the value of `readReceipts`. Subsequent reads from it will return its default value.
    mutating func clearReadReceipts() {_uniqueStorage()._readReceipts = nil}

    /// @required
    var sealedSenderIndicators: Bool {
      get {return _storage._sealedSenderIndicators ?? false}
      set {_uniqueStorage()._sealedSenderIndicators = newValue}
    }
    /// Returns true if `sealedSenderIndicators` has been explicitly set.
    var hasSealedSenderIndicators: Bool {return _storage._sealedSenderIndicators != nil}
    /// Clears the value of `sealedSenderIndicators`. Subsequent reads from it will return its default value.
    mutating func clearSealedSenderIndicators() {_uniqueStorage()._sealedSenderIndicators = nil}

    /// @required
    var typingIndicators: Bool {
      get {return _storage._typingIndicators ?? false}
      set {_uniqueStorage()._typingIndicators = newValue}
    }
    /// Returns true if `typingIndicators` has been explicitly set.
    var hasTypingIndicators: Bool {return _storage._typingIndicators != nil}
    /// Clears the value of `typingIndicators`. Subsequent reads from it will return its default value.
    mutating func clearTypingIndicators() {_uniqueStorage()._typingIndicators = nil}

    /// @required
    var proxiedLinkPreviews: Bool {
      get {return _storage._proxiedLinkPreviews ?? false}
      set {_uniqueStorage()._proxiedLinkPreviews = newValue}
    }
    /// Returns true if `proxiedLinkPreviews` has been explicitly set.
    var hasProxiedLinkPreviews: Bool {return _storage._proxiedLinkPreviews != nil}
    /// Clears the value of `proxiedLinkPreviews`. Subsequent reads from it will return its default value.
    mutating func clearProxiedLinkPreviews() {_uniqueStorage()._proxiedLinkPreviews = nil}

    /// @required
    var noteToSelfMarkedUnread: Bool {
      get {return _storage._noteToSelfMarkedUnread ?? false}
      set {_uniqueStorage()._noteToSelfMarkedUnread = newValue}
    }
    /// Returns true if `noteToSelfMarkedUnread` has been explicitly set.
    var hasNoteToSelfMarkedUnread: Bool {return _storage._noteToSelfMarkedUnread != nil}
    /// Clears the value of `noteToSelfMarkedUnread`. Subsequent reads from it will return its default value.
    mutating func clearNoteToSelfMarkedUnread() {_uniqueStorage()._noteToSelfMarkedUnread = nil}

    /// @required
    var linkPreviews: Bool {
      get {return _storage._linkPreviews ?? false}
      set {_uniqueStorage()._linkPreviews = newValue}
    }
    /// Returns true if `linkPreviews` has been explicitly set.
    var hasLinkPreviews: Bool {return _storage._linkPreviews != nil}
    /// Clears the value of `linkPreviews`. Subsequent reads from it will return its default value.
    mutating func clearLinkPreviews() {_uniqueStorage()._linkPreviews = nil}

    /// @required
    var unlistedPhoneNumber: Bool {
      get {return _storage._unlistedPhoneNumber ?? false}
      set {_uniqueStorage()._unlistedPhoneNumber = newValue}
    }
    /// Returns true if `unlistedPhoneNumber` has been explicitly set.
    var hasUnlistedPhoneNumber: Bool {return _storage._unlistedPhoneNumber != nil}
    /// Clears the value of `unlistedPhoneNumber`. Subsequent reads from it will return its default value.
    mutating func clearUnlistedPhoneNumber() {_uniqueStorage()._unlistedPhoneNumber = nil}

    /// @required
    var preferContactAvatars: Bool {
      get {return _storage._preferContactAvatars ?? false}
      set {_uniqueStorage()._preferContactAvatars = newValue}
    }
    /// Returns true if `preferContactAvatars` has been explicitly set.
    var hasPreferContactAvatars: Bool {return _storage._preferContactAvatars != nil}
    /// Clears the value of `preferContactAvatars`. Subsequent reads from it will return its default value.
    mutating func clearPreferContactAvatars() {_uniqueStorage()._preferContactAvatars = nil}

    /// @required
    var universalExpireTimer: UInt32 {
      get {return _storage._universalExpireTimer ?? 0}
      set {_uniqueStorage()._universalExpireTimer = newValue}
    }
    /// Returns true if `universalExpireTimer` has been explicitly set.
    var hasUniversalExpireTimer: Bool {return _storage._universalExpireTimer != nil}
    /// Clears the value of `universalExpireTimer`. Subsequent reads from it will return its default value.
    mutating func clearUniversalExpireTimer() {_uniqueStorage()._universalExpireTimer = nil}

    var preferredReactionEmoji: [String] {
      get {return _storage._preferredReactionEmoji}
      set {_uniqueStorage()._preferredReactionEmoji = newValue}
    }

    /// @required
    var displayBadgesOnProfile: Bool {
      get {return _storage._displayBadgesOnProfile ?? false}
      set {_uniqueStorage()._displayBadgesOnProfile = newValue}
    }
    /// Returns true if `displayBadgesOnProfile` has been explicitly set.
    var hasDisplayBadgesOnProfile: Bool {return _storage._displayBadgesOnProfile != nil}
    /// Clears the value of `displayBadgesOnProfile`. Subsequent reads from it will return its default value.
    mutating func clearDisplayBadgesOnProfile() {_uniqueStorage()._displayBadgesOnProfile = nil}

    /// @required
    var keepMutedChatsArchived: Bool {
      get {return _storage._keepMutedChatsArchived ?? false}
      set {_uniqueStorage()._keepMutedChatsArchived = newValue}
    }
    /// Returns true if `keepMutedChatsArchived` has been explicitly set.
    var hasKeepMutedChatsArchived: Bool {return _storage._keepMutedChatsArchived != nil}
    /// Clears the value of `keepMutedChatsArchived`. Subsequent reads from it will return its default value.
    mutating func clearKeepMutedChatsArchived() {_uniqueStorage()._keepMutedChatsArchived = nil}

    /// @required
    var myStoriesPrivacyHasBeenSet: Bool {
      get {return _storage._myStoriesPrivacyHasBeenSet ?? false}
      set {_uniqueStorage()._myStoriesPrivacyHasBeenSet = newValue}
    }
    /// Returns true if `myStoriesPrivacyHasBeenSet` has been explicitly set.
    var hasMyStoriesPrivacyHasBeenSet: Bool {return _storage._myStoriesPrivacyHasBeenSet != nil}
    /// Clears the value of `myStoriesPrivacyHasBeenSet`. Subsequent reads from it will return its default value.
    mutating func clearMyStoriesPrivacyHasBeenSet() {_uniqueStorage()._myStoriesPrivacyHasBeenSet = nil}

    /// @required
    var onboardingStoryHasBeenViewed: Bool {
      get {return _storage._onboardingStoryHasBeenViewed ?? false}
      set {_uniqueStorage()._onboardingStoryHasBeenViewed = newValue}
    }
    /// Returns true if `onboardingStoryHasBeenViewed` has been explicitly set.
    var hasOnboardingStoryHasBeenViewed: Bool {return _storage._onboardingStoryHasBeenViewed != nil}
    /// Clears the value of `onboardingStoryHasBeenViewed`. Subsequent reads from it will return its default value.
    mutating func clearOnboardingStoryHasBeenViewed() {_uniqueStorage()._onboardingStoryHasBeenViewed = nil}

    /// @required
    var storiesDisabled: Bool {
      get {return _storage._storiesDisabled ?? false}
      set {_uniqueStorage()._storiesDisabled = newValue}
    }
    /// Returns true if `storiesDisabled` has been explicitly set.
    var hasStoriesDisabled: Bool {return _storage._storiesDisabled != nil}
    /// Clears the value of `storiesDisabled`. Subsequent reads from it will return its default value.
    mutating func clearStoriesDisabled() {_uniqueStorage()._storiesDisabled = nil}

    var storyViewReceiptsEnabled: Bool {
      get {return _storage._storyViewReceiptsEnabled ?? false}
      set {_uniqueStorage()._storyViewReceiptsEnabled = newValue}
    }
    /// Returns true if `storyViewReceiptsEnabled` has been explicitly set.
    var hasStoryViewReceiptsEnabled: Bool {return _storage._storyViewReceiptsEnabled != nil}
    /// Clears the value of `storyViewReceiptsEnabled`. Subsequent reads from it will return its default value.
    mutating func clearStoryViewReceiptsEnabled() {_uniqueStorage()._storyViewReceiptsEnabled = nil}

    /// @required
    var onboardingStoryHasBeenRead: Bool {
      get {return _storage._onboardingStoryHasBeenRead ?? false}
      set {_uniqueStorage()._onboardingStoryHasBeenRead = newValue}
    }
    /// Returns true if `onboardingStoryHasBeenRead` has been explicitly set.
    var hasOnboardingStoryHasBeenRead: Bool {return _storage._onboardingStoryHasBeenRead != nil}
    /// Clears the value of `onboardingStoryHasBeenRead`. Subsequent reads from it will return its default value.
    mutating func clearOnboardingStoryHasBeenRead() {_uniqueStorage()._onboardingStoryHasBeenRead = nil}

    /// @required
    var groupStoryEducationSheetHasBeenSet: Bool {
      get {return _storage._groupStoryEducationSheetHasBeenSet ?? false}
      set {_uniqueStorage()._groupStoryEducationSheetHasBeenSet = newValue}
    }
    /// Returns true if `groupStoryEducationSheetHasBeenSet` has been explicitly set.
    var hasGroupStoryEducationSheetHasBeenSet: Bool {return _storage._groupStoryEducationSheetHasBeenSet != nil}
    /// Clears the value of `groupStoryEducationSheetHasBeenSet`. Subsequent reads from it will return its default value.
    mutating func clearGroupStoryEducationSheetHasBeenSet() {_uniqueStorage()._groupStoryEducationSheetHasBeenSet = nil}

    /// @required
    var usernameOnboardingHasBeenCompleted: Bool {
      get {return _storage._usernameOnboardingHasBeenCompleted ?? false}
      set {_uniqueStorage()._usernameOnboardingHasBeenCompleted = newValue}
    }
    /// Returns true if `usernameOnboardingHasBeenCompleted` has been explicitly set.
    var hasUsernameOnboardingHasBeenCompleted: Bool {return _storage._usernameOnboardingHasBeenCompleted != nil}
    /// Clears the value of `usernameOnboardingHasBeenCompleted`. Subsequent reads from it will return its default value.
    mutating func clearUsernameOnboardingHasBeenCompleted() {_uniqueStorage()._usernameOnboardingHasBeenCompleted = nil}

    var phoneNumberSharingMode: BackupProtos_AccountData.PhoneNumberSharingMode {
      get {return _storage._phoneNumberSharingMode ?? .everybody}
      set {_uniqueStorage()._phoneNumberSharingMode = newValue}
    }
    /// Returns true if `phoneNumberSharingMode` has been explicitly set.
    var hasPhoneNumberSharingMode: Bool {return _storage._phoneNumberSharingMode != nil}
    /// Clears the value of `phoneNumberSharingMode`. Subsequent reads from it will return its default value.
    mutating func clearPhoneNumberSharingMode() {_uniqueStorage()._phoneNumberSharingMode = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension BackupProtos_AccountData.PhoneNumberSharingMode: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_AccountData.UsernameLink.Color: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Recipient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: UInt64 {
    get {return _storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  /// oneof destination {
  var contact: BackupProtos_Contact {
    get {return _storage._contact ?? BackupProtos_Contact()}
    set {_uniqueStorage()._contact = newValue}
  }
  /// Returns true if `contact` has been explicitly set.
  var hasContact: Bool {return _storage._contact != nil}
  /// Clears the value of `contact`. Subsequent reads from it will return its default value.
  mutating func clearContact() {_uniqueStorage()._contact = nil}

  var group: BackupProtos_Group {
    get {return _storage._group ?? BackupProtos_Group()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {_uniqueStorage()._group = nil}

  var distributionList: BackupProtos_DistributionList {
    get {return _storage._distributionList ?? BackupProtos_DistributionList()}
    set {_uniqueStorage()._distributionList = newValue}
  }
  /// Returns true if `distributionList` has been explicitly set.
  var hasDistributionList: Bool {return _storage._distributionList != nil}
  /// Clears the value of `distributionList`. Subsequent reads from it will return its default value.
  mutating func clearDistributionList() {_uniqueStorage()._distributionList = nil}

  /// }
  var selfRecipient: BackupProtos_SelfRecipient {
    get {return _storage._selfRecipient ?? BackupProtos_SelfRecipient()}
    set {_uniqueStorage()._selfRecipient = newValue}
  }
  /// Returns true if `selfRecipient` has been explicitly set.
  var hasSelfRecipient: Bool {return _storage._selfRecipient != nil}
  /// Clears the value of `selfRecipient`. Subsequent reads from it will return its default value.
  mutating func clearSelfRecipient() {_uniqueStorage()._selfRecipient = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// should be 16 bytes
  var aci: Data {
    get {return _aci ?? Data()}
    set {_aci = newValue}
  }
  /// Returns true if `aci` has been explicitly set.
  var hasAci: Bool {return self._aci != nil}
  /// Clears the value of `aci`. Subsequent reads from it will return its default value.
  mutating func clearAci() {self._aci = nil}

  /// should be 16 bytes
  var pni: Data {
    get {return _pni ?? Data()}
    set {_pni = newValue}
  }
  /// Returns true if `pni` has been explicitly set.
  var hasPni: Bool {return self._pni != nil}
  /// Clears the value of `pni`. Subsequent reads from it will return its default value.
  mutating func clearPni() {self._pni = nil}

  var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {self._username = nil}

  var e164: UInt64 {
    get {return _e164 ?? 0}
    set {_e164 = newValue}
  }
  /// Returns true if `e164` has been explicitly set.
  var hasE164: Bool {return self._e164 != nil}
  /// Clears the value of `e164`. Subsequent reads from it will return its default value.
  mutating func clearE164() {self._e164 = nil}

  /// @required
  var blocked: Bool {
    get {return _blocked ?? false}
    set {_blocked = newValue}
  }
  /// Returns true if `blocked` has been explicitly set.
  var hasBlocked: Bool {return self._blocked != nil}
  /// Clears the value of `blocked`. Subsequent reads from it will return its default value.
  mutating func clearBlocked() {self._blocked = nil}

  /// @required
  var hidden: Bool {
    get {return _hidden ?? false}
    set {_hidden = newValue}
  }
  /// Returns true if `hidden` has been explicitly set.
  var hasHidden: Bool {return self._hidden != nil}
  /// Clears the value of `hidden`. Subsequent reads from it will return its default value.
  mutating func clearHidden() {self._hidden = nil}

  var registered: BackupProtos_Contact.Registered {
    get {return _registered ?? .unknown}
    set {_registered = newValue}
  }
  /// Returns true if `registered` has been explicitly set.
  var hasRegistered: Bool {return self._registered != nil}
  /// Clears the value of `registered`. Subsequent reads from it will return its default value.
  mutating func clearRegistered() {self._registered = nil}

  /// @required
  var unregisteredTimestamp: UInt64 {
    get {return _unregisteredTimestamp ?? 0}
    set {_unregisteredTimestamp = newValue}
  }
  /// Returns true if `unregisteredTimestamp` has been explicitly set.
  var hasUnregisteredTimestamp: Bool {return self._unregisteredTimestamp != nil}
  /// Clears the value of `unregisteredTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearUnregisteredTimestamp() {self._unregisteredTimestamp = nil}

  var profileKey: Data {
    get {return _profileKey ?? Data()}
    set {_profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return self._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {self._profileKey = nil}

  /// @required
  var profileSharing: Bool {
    get {return _profileSharing ?? false}
    set {_profileSharing = newValue}
  }
  /// Returns true if `profileSharing` has been explicitly set.
  var hasProfileSharing: Bool {return self._profileSharing != nil}
  /// Clears the value of `profileSharing`. Subsequent reads from it will return its default value.
  mutating func clearProfileSharing() {self._profileSharing = nil}

  var profileGivenName: String {
    get {return _profileGivenName ?? String()}
    set {_profileGivenName = newValue}
  }
  /// Returns true if `profileGivenName` has been explicitly set.
  var hasProfileGivenName: Bool {return self._profileGivenName != nil}
  /// Clears the value of `profileGivenName`. Subsequent reads from it will return its default value.
  mutating func clearProfileGivenName() {self._profileGivenName = nil}

  var profileFamilyName: String {
    get {return _profileFamilyName ?? String()}
    set {_profileFamilyName = newValue}
  }
  /// Returns true if `profileFamilyName` has been explicitly set.
  var hasProfileFamilyName: Bool {return self._profileFamilyName != nil}
  /// Clears the value of `profileFamilyName`. Subsequent reads from it will return its default value.
  mutating func clearProfileFamilyName() {self._profileFamilyName = nil}

  var profileJoinedName: String {
    get {return _profileJoinedName ?? String()}
    set {_profileJoinedName = newValue}
  }
  /// Returns true if `profileJoinedName` has been explicitly set.
  var hasProfileJoinedName: Bool {return self._profileJoinedName != nil}
  /// Clears the value of `profileJoinedName`. Subsequent reads from it will return its default value.
  mutating func clearProfileJoinedName() {self._profileJoinedName = nil}

  /// @required
  var hideStory: Bool {
    get {return _hideStory ?? false}
    set {_hideStory = newValue}
  }
  /// Returns true if `hideStory` has been explicitly set.
  var hasHideStory: Bool {return self._hideStory != nil}
  /// Clears the value of `hideStory`. Subsequent reads from it will return its default value.
  mutating func clearHideStory() {self._hideStory = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Registered: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case registered // = 1
    case notRegistered // = 2

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .registered
      case 2: self = .notRegistered
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .registered: return 1
      case .notRegistered: return 2
      }
    }

  }

  init() {}

  fileprivate var _aci: Data? = nil
  fileprivate var _pni: Data? = nil
  fileprivate var _username: String? = nil
  fileprivate var _e164: UInt64? = nil
  fileprivate var _blocked: Bool? = nil
  fileprivate var _hidden: Bool? = nil
  fileprivate var _registered: BackupProtos_Contact.Registered? = nil
  fileprivate var _unregisteredTimestamp: UInt64? = nil
  fileprivate var _profileKey: Data? = nil
  fileprivate var _profileSharing: Bool? = nil
  fileprivate var _profileGivenName: String? = nil
  fileprivate var _profileFamilyName: String? = nil
  fileprivate var _profileJoinedName: String? = nil
  fileprivate var _hideStory: Bool? = nil
}

#if swift(>=4.2)

extension BackupProtos_Contact.Registered: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var masterKey: Data {
    get {return _masterKey ?? Data()}
    set {_masterKey = newValue}
  }
  /// Returns true if `masterKey` has been explicitly set.
  var hasMasterKey: Bool {return self._masterKey != nil}
  /// Clears the value of `masterKey`. Subsequent reads from it will return its default value.
  mutating func clearMasterKey() {self._masterKey = nil}

  /// @required
  var whitelisted: Bool {
    get {return _whitelisted ?? false}
    set {_whitelisted = newValue}
  }
  /// Returns true if `whitelisted` has been explicitly set.
  var hasWhitelisted: Bool {return self._whitelisted != nil}
  /// Clears the value of `whitelisted`. Subsequent reads from it will return its default value.
  mutating func clearWhitelisted() {self._whitelisted = nil}

  /// @required
  var hideStory: Bool {
    get {return _hideStory ?? false}
    set {_hideStory = newValue}
  }
  /// Returns true if `hideStory` has been explicitly set.
  var hasHideStory: Bool {return self._hideStory != nil}
  /// Clears the value of `hideStory`. Subsequent reads from it will return its default value.
  mutating func clearHideStory() {self._hideStory = nil}

  var storySendMode: BackupProtos_Group.StorySendMode {
    get {return _storySendMode ?? .default}
    set {_storySendMode = newValue}
  }
  /// Returns true if `storySendMode` has been explicitly set.
  var hasStorySendMode: Bool {return self._storySendMode != nil}
  /// Clears the value of `storySendMode`. Subsequent reads from it will return its default value.
  mutating func clearStorySendMode() {self._storySendMode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StorySendMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case disabled // = 1
    case enabled // = 2

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .disabled
      case 2: self = .enabled
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .disabled: return 1
      case .enabled: return 2
      }
    }

  }

  init() {}

  fileprivate var _masterKey: Data? = nil
  fileprivate var _whitelisted: Bool? = nil
  fileprivate var _hideStory: Bool? = nil
  fileprivate var _storySendMode: BackupProtos_Group.StorySendMode? = nil
}

#if swift(>=4.2)

extension BackupProtos_Group.StorySendMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_SelfRecipient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_Chat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: UInt64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// @required
  var recipientID: UInt64 {
    get {return _recipientID ?? 0}
    set {_recipientID = newValue}
  }
  /// Returns true if `recipientID` has been explicitly set.
  var hasRecipientID: Bool {return self._recipientID != nil}
  /// Clears the value of `recipientID`. Subsequent reads from it will return its default value.
  mutating func clearRecipientID() {self._recipientID = nil}

  /// @required
  var archived: Bool {
    get {return _archived ?? false}
    set {_archived = newValue}
  }
  /// Returns true if `archived` has been explicitly set.
  var hasArchived: Bool {return self._archived != nil}
  /// Clears the value of `archived`. Subsequent reads from it will return its default value.
  mutating func clearArchived() {self._archived = nil}

  /// @required
  var pinned: Bool {
    get {return _pinned ?? false}
    set {_pinned = newValue}
  }
  /// Returns true if `pinned` has been explicitly set.
  var hasPinned: Bool {return self._pinned != nil}
  /// Clears the value of `pinned`. Subsequent reads from it will return its default value.
  mutating func clearPinned() {self._pinned = nil}

  /// @required
  var expirationTimer: UInt64 {
    get {return _expirationTimer ?? 0}
    set {_expirationTimer = newValue}
  }
  /// Returns true if `expirationTimer` has been explicitly set.
  var hasExpirationTimer: Bool {return self._expirationTimer != nil}
  /// Clears the value of `expirationTimer`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTimer() {self._expirationTimer = nil}

  /// @required
  var muteUntil: UInt64 {
    get {return _muteUntil ?? 0}
    set {_muteUntil = newValue}
  }
  /// Returns true if `muteUntil` has been explicitly set.
  var hasMuteUntil: Bool {return self._muteUntil != nil}
  /// Clears the value of `muteUntil`. Subsequent reads from it will return its default value.
  mutating func clearMuteUntil() {self._muteUntil = nil}

  /// @required
  var markedUnread: Bool {
    get {return _markedUnread ?? false}
    set {_markedUnread = newValue}
  }
  /// Returns true if `markedUnread` has been explicitly set.
  var hasMarkedUnread: Bool {return self._markedUnread != nil}
  /// Clears the value of `markedUnread`. Subsequent reads from it will return its default value.
  mutating func clearMarkedUnread() {self._markedUnread = nil}

  /// @required
  var dontNotifyForMentionsIfMuted: Bool {
    get {return _dontNotifyForMentionsIfMuted ?? false}
    set {_dontNotifyForMentionsIfMuted = newValue}
  }
  /// Returns true if `dontNotifyForMentionsIfMuted` has been explicitly set.
  var hasDontNotifyForMentionsIfMuted: Bool {return self._dontNotifyForMentionsIfMuted != nil}
  /// Clears the value of `dontNotifyForMentionsIfMuted`. Subsequent reads from it will return its default value.
  mutating func clearDontNotifyForMentionsIfMuted() {self._dontNotifyForMentionsIfMuted = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: UInt64? = nil
  fileprivate var _recipientID: UInt64? = nil
  fileprivate var _archived: Bool? = nil
  fileprivate var _pinned: Bool? = nil
  fileprivate var _expirationTimer: UInt64? = nil
  fileprivate var _muteUntil: UInt64? = nil
  fileprivate var _markedUnread: Bool? = nil
  fileprivate var _dontNotifyForMentionsIfMuted: Bool? = nil
}

struct BackupProtos_DistributionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// @required
  var distributionID: Data {
    get {return _distributionID ?? Data()}
    set {_distributionID = newValue}
  }
  /// Returns true if `distributionID` has been explicitly set.
  var hasDistributionID: Bool {return self._distributionID != nil}
  /// Clears the value of `distributionID`. Subsequent reads from it will return its default value.
  mutating func clearDistributionID() {self._distributionID = nil}

  /// @required
  var allowReplies: Bool {
    get {return _allowReplies ?? false}
    set {_allowReplies = newValue}
  }
  /// Returns true if `allowReplies` has been explicitly set.
  var hasAllowReplies: Bool {return self._allowReplies != nil}
  /// Clears the value of `allowReplies`. Subsequent reads from it will return its default value.
  mutating func clearAllowReplies() {self._allowReplies = nil}

  /// @required
  var deletionTimestamp: UInt64 {
    get {return _deletionTimestamp ?? 0}
    set {_deletionTimestamp = newValue}
  }
  /// Returns true if `deletionTimestamp` has been explicitly set.
  var hasDeletionTimestamp: Bool {return self._deletionTimestamp != nil}
  /// Clears the value of `deletionTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearDeletionTimestamp() {self._deletionTimestamp = nil}

  /// @required
  var isUnknown: Bool {
    get {return _isUnknown ?? false}
    set {_isUnknown = newValue}
  }
  /// Returns true if `isUnknown` has been explicitly set.
  var hasIsUnknown: Bool {return self._isUnknown != nil}
  /// Clears the value of `isUnknown`. Subsequent reads from it will return its default value.
  mutating func clearIsUnknown() {self._isUnknown = nil}

  var privacyMode: BackupProtos_DistributionList.PrivacyMode {
    get {return _privacyMode ?? .onlyWith}
    set {_privacyMode = newValue}
  }
  /// Returns true if `privacyMode` has been explicitly set.
  var hasPrivacyMode: Bool {return self._privacyMode != nil}
  /// Clears the value of `privacyMode`. Subsequent reads from it will return its default value.
  mutating func clearPrivacyMode() {self._privacyMode = nil}

  /// generated recipient id
  var memberRecipientIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PrivacyMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case onlyWith // = 0
    case allExcept // = 1
    case all // = 2

    init() {
      self = .onlyWith
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .onlyWith
      case 1: self = .allExcept
      case 2: self = .all
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .onlyWith: return 0
      case .allExcept: return 1
      case .all: return 2
      }
    }

  }

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _distributionID: Data? = nil
  fileprivate var _allowReplies: Bool? = nil
  fileprivate var _deletionTimestamp: UInt64? = nil
  fileprivate var _isUnknown: Bool? = nil
  fileprivate var _privacyMode: BackupProtos_DistributionList.PrivacyMode? = nil
}

#if swift(>=4.2)

extension BackupProtos_DistributionList.PrivacyMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var serviceID: Data {
    get {return _serviceID ?? Data()}
    set {_serviceID = newValue}
  }
  /// Returns true if `serviceID` has been explicitly set.
  var hasServiceID: Bool {return self._serviceID != nil}
  /// Clears the value of `serviceID`. Subsequent reads from it will return its default value.
  mutating func clearServiceID() {self._serviceID = nil}

  /// @required
  var identityKey: Data {
    get {return _identityKey ?? Data()}
    set {_identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  var hasIdentityKey: Bool {return self._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  mutating func clearIdentityKey() {self._identityKey = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// @required
  var firstUse: Bool {
    get {return _firstUse ?? false}
    set {_firstUse = newValue}
  }
  /// Returns true if `firstUse` has been explicitly set.
  var hasFirstUse: Bool {return self._firstUse != nil}
  /// Clears the value of `firstUse`. Subsequent reads from it will return its default value.
  mutating func clearFirstUse() {self._firstUse = nil}

  /// @required
  var verified: Bool {
    get {return _verified ?? false}
    set {_verified = newValue}
  }
  /// Returns true if `verified` has been explicitly set.
  var hasVerified: Bool {return self._verified != nil}
  /// Clears the value of `verified`. Subsequent reads from it will return its default value.
  mutating func clearVerified() {self._verified = nil}

  /// @required
  var nonblockingApproval: Bool {
    get {return _nonblockingApproval ?? false}
    set {_nonblockingApproval = newValue}
  }
  /// Returns true if `nonblockingApproval` has been explicitly set.
  var hasNonblockingApproval: Bool {return self._nonblockingApproval != nil}
  /// Clears the value of `nonblockingApproval`. Subsequent reads from it will return its default value.
  mutating func clearNonblockingApproval() {self._nonblockingApproval = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceID: Data? = nil
  fileprivate var _identityKey: Data? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _firstUse: Bool? = nil
  fileprivate var _verified: Bool? = nil
  fileprivate var _nonblockingApproval: Bool? = nil
}

struct BackupProtos_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var callID: UInt64 {
    get {return _callID ?? 0}
    set {_callID = newValue}
  }
  /// Returns true if `callID` has been explicitly set.
  var hasCallID: Bool {return self._callID != nil}
  /// Clears the value of `callID`. Subsequent reads from it will return its default value.
  mutating func clearCallID() {self._callID = nil}

  /// @required
  var peerRecipientID: UInt64 {
    get {return _peerRecipientID ?? 0}
    set {_peerRecipientID = newValue}
  }
  /// Returns true if `peerRecipientID` has been explicitly set.
  var hasPeerRecipientID: Bool {return self._peerRecipientID != nil}
  /// Clears the value of `peerRecipientID`. Subsequent reads from it will return its default value.
  mutating func clearPeerRecipientID() {self._peerRecipientID = nil}

  var type: BackupProtos_Call.TypeEnum {
    get {return _type ?? .audioCall}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// @required
  var outgoing: Bool {
    get {return _outgoing ?? false}
    set {_outgoing = newValue}
  }
  /// Returns true if `outgoing` has been explicitly set.
  var hasOutgoing: Bool {return self._outgoing != nil}
  /// Clears the value of `outgoing`. Subsequent reads from it will return its default value.
  mutating func clearOutgoing() {self._outgoing = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// @required
  var ringerRecipientID: UInt64 {
    get {return _ringerRecipientID ?? 0}
    set {_ringerRecipientID = newValue}
  }
  /// Returns true if `ringerRecipientID` has been explicitly set.
  var hasRingerRecipientID: Bool {return self._ringerRecipientID != nil}
  /// Clears the value of `ringerRecipientID`. Subsequent reads from it will return its default value.
  mutating func clearRingerRecipientID() {self._ringerRecipientID = nil}

  var event: BackupProtos_Call.Event {
    get {return _event ?? .outgoing}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  mutating func clearEvent() {self._event = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case audioCall // = 0
    case videoCall // = 1
    case groupCall // = 2
    case adHocCall // = 3

    init() {
      self = .audioCall
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .audioCall
      case 1: self = .videoCall
      case 2: self = .groupCall
      case 3: self = .adHocCall
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .audioCall: return 0
      case .videoCall: return 1
      case .groupCall: return 2
      case .adHocCall: return 3
      }
    }

  }

  enum Event: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// 1:1 calls only
    case outgoing // = 0

    /// 1:1 and group calls. Group calls: You accepted a ring.
    case accepted // = 1

    /// 1:1 calls only,
    case notAccepted // = 2

    /// 1:1 and group/ad-hoc calls. Group calls: The remote ring has expired or was cancelled by the ringer.
    case missed // = 3

    /// 1:1 and Group/Ad-Hoc Calls.
    case delete // = 4

    /// Group/Ad-Hoc Calls only. Initial state
    case genericGroupCall // = 5

    /// Group Calls: User has joined the group call.
    case joined // = 6

    /// Group Calls: If a ring was requested by another user.
    case ringing // = 7

    /// Group Calls: If you declined a ring.
    case declined // = 8

    /// Group Calls: If you are ringing a group.
    case outgoingRing // = 9

    init() {
      self = .outgoing
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .outgoing
      case 1: self = .accepted
      case 2: self = .notAccepted
      case 3: self = .missed
      case 4: self = .delete
      case 5: self = .genericGroupCall
      case 6: self = .joined
      case 7: self = .ringing
      case 8: self = .declined
      case 9: self = .outgoingRing
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .outgoing: return 0
      case .accepted: return 1
      case .notAccepted: return 2
      case .missed: return 3
      case .delete: return 4
      case .genericGroupCall: return 5
      case .joined: return 6
      case .ringing: return 7
      case .declined: return 8
      case .outgoingRing: return 9
      }
    }

  }

  init() {}

  fileprivate var _callID: UInt64? = nil
  fileprivate var _peerRecipientID: UInt64? = nil
  fileprivate var _type: BackupProtos_Call.TypeEnum? = nil
  fileprivate var _outgoing: Bool? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _ringerRecipientID: UInt64? = nil
  fileprivate var _event: BackupProtos_Call.Event? = nil
}

#if swift(>=4.2)

extension BackupProtos_Call.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_Call.Event: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_ChatItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var chatID: UInt64 {
    get {return _storage._chatID ?? 0}
    set {_uniqueStorage()._chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  var hasChatID: Bool {return _storage._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  mutating func clearChatID() {_uniqueStorage()._chatID = nil}

  /// @required
  var authorID: UInt64 {
    get {return _storage._authorID ?? 0}
    set {_uniqueStorage()._authorID = newValue}
  }
  /// Returns true if `authorID` has been explicitly set.
  var hasAuthorID: Bool {return _storage._authorID != nil}
  /// Clears the value of `authorID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorID() {_uniqueStorage()._authorID = nil}

  /// @required
  var dateSent: UInt64 {
    get {return _storage._dateSent ?? 0}
    set {_uniqueStorage()._dateSent = newValue}
  }
  /// Returns true if `dateSent` has been explicitly set.
  var hasDateSent: Bool {return _storage._dateSent != nil}
  /// Clears the value of `dateSent`. Subsequent reads from it will return its default value.
  mutating func clearDateSent() {_uniqueStorage()._dateSent = nil}

  /// @required
  var dateReceived: UInt64 {
    get {return _storage._dateReceived ?? 0}
    set {_uniqueStorage()._dateReceived = newValue}
  }
  /// Returns true if `dateReceived` has been explicitly set.
  var hasDateReceived: Bool {return _storage._dateReceived != nil}
  /// Clears the value of `dateReceived`. Subsequent reads from it will return its default value.
  mutating func clearDateReceived() {_uniqueStorage()._dateReceived = nil}

  /// timestamp of when expiration timer started ticking down
  var expireStart: UInt64 {
    get {return _storage._expireStart ?? 0}
    set {_uniqueStorage()._expireStart = newValue}
  }
  /// Returns true if `expireStart` has been explicitly set.
  var hasExpireStart: Bool {return _storage._expireStart != nil}
  /// Clears the value of `expireStart`. Subsequent reads from it will return its default value.
  mutating func clearExpireStart() {_uniqueStorage()._expireStart = nil}

  /// how long timer of message is (ms)
  var expiresIn: UInt64 {
    get {return _storage._expiresIn ?? 0}
    set {_uniqueStorage()._expiresIn = newValue}
  }
  /// Returns true if `expiresIn` has been explicitly set.
  var hasExpiresIn: Bool {return _storage._expiresIn != nil}
  /// Clears the value of `expiresIn`. Subsequent reads from it will return its default value.
  mutating func clearExpiresIn() {_uniqueStorage()._expiresIn = nil}

  var revisions: [BackupProtos_ChatItem] {
    get {return _storage._revisions}
    set {_uniqueStorage()._revisions = newValue}
  }

  /// @required
  var sms: Bool {
    get {return _storage._sms ?? false}
    set {_uniqueStorage()._sms = newValue}
  }
  /// Returns true if `sms` has been explicitly set.
  var hasSms: Bool {return _storage._sms != nil}
  /// Clears the value of `sms`. Subsequent reads from it will return its default value.
  mutating func clearSms() {_uniqueStorage()._sms = nil}

  /// oneof directionalDetails {
  var incoming: BackupProtos_ChatItem.IncomingMessageDetails {
    get {return _storage._incoming ?? BackupProtos_ChatItem.IncomingMessageDetails()}
    set {_uniqueStorage()._incoming = newValue}
  }
  /// Returns true if `incoming` has been explicitly set.
  var hasIncoming: Bool {return _storage._incoming != nil}
  /// Clears the value of `incoming`. Subsequent reads from it will return its default value.
  mutating func clearIncoming() {_uniqueStorage()._incoming = nil}

  /// }
  var outgoing: BackupProtos_ChatItem.OutgoingMessageDetails {
    get {return _storage._outgoing ?? BackupProtos_ChatItem.OutgoingMessageDetails()}
    set {_uniqueStorage()._outgoing = newValue}
  }
  /// Returns true if `outgoing` has been explicitly set.
  var hasOutgoing: Bool {return _storage._outgoing != nil}
  /// Clears the value of `outgoing`. Subsequent reads from it will return its default value.
  mutating func clearOutgoing() {_uniqueStorage()._outgoing = nil}

  /// oneof item {
  var standardMessage: BackupProtos_StandardMessage {
    get {return _storage._standardMessage ?? BackupProtos_StandardMessage()}
    set {_uniqueStorage()._standardMessage = newValue}
  }
  /// Returns true if `standardMessage` has been explicitly set.
  var hasStandardMessage: Bool {return _storage._standardMessage != nil}
  /// Clears the value of `standardMessage`. Subsequent reads from it will return its default value.
  mutating func clearStandardMessage() {_uniqueStorage()._standardMessage = nil}

  var contactMessage: BackupProtos_ContactMessage {
    get {return _storage._contactMessage ?? BackupProtos_ContactMessage()}
    set {_uniqueStorage()._contactMessage = newValue}
  }
  /// Returns true if `contactMessage` has been explicitly set.
  var hasContactMessage: Bool {return _storage._contactMessage != nil}
  /// Clears the value of `contactMessage`. Subsequent reads from it will return its default value.
  mutating func clearContactMessage() {_uniqueStorage()._contactMessage = nil}

  var voiceMessage: BackupProtos_VoiceMessage {
    get {return _storage._voiceMessage ?? BackupProtos_VoiceMessage()}
    set {_uniqueStorage()._voiceMessage = newValue}
  }
  /// Returns true if `voiceMessage` has been explicitly set.
  var hasVoiceMessage: Bool {return _storage._voiceMessage != nil}
  /// Clears the value of `voiceMessage`. Subsequent reads from it will return its default value.
  mutating func clearVoiceMessage() {_uniqueStorage()._voiceMessage = nil}

  var stickerMessage: BackupProtos_StickerMessage {
    get {return _storage._stickerMessage ?? BackupProtos_StickerMessage()}
    set {_uniqueStorage()._stickerMessage = newValue}
  }
  /// Returns true if `stickerMessage` has been explicitly set.
  var hasStickerMessage: Bool {return _storage._stickerMessage != nil}
  /// Clears the value of `stickerMessage`. Subsequent reads from it will return its default value.
  mutating func clearStickerMessage() {_uniqueStorage()._stickerMessage = nil}

  var remoteDeletedMessage: BackupProtos_RemoteDeletedMessage {
    get {return _storage._remoteDeletedMessage ?? BackupProtos_RemoteDeletedMessage()}
    set {_uniqueStorage()._remoteDeletedMessage = newValue}
  }
  /// Returns true if `remoteDeletedMessage` has been explicitly set.
  var hasRemoteDeletedMessage: Bool {return _storage._remoteDeletedMessage != nil}
  /// Clears the value of `remoteDeletedMessage`. Subsequent reads from it will return its default value.
  mutating func clearRemoteDeletedMessage() {_uniqueStorage()._remoteDeletedMessage = nil}

  /// }
  var updateMessage: BackupProtos_UpdateMessage {
    get {return _storage._updateMessage ?? BackupProtos_UpdateMessage()}
    set {_uniqueStorage()._updateMessage = newValue}
  }
  /// Returns true if `updateMessage` has been explicitly set.
  var hasUpdateMessage: Bool {return _storage._updateMessage != nil}
  /// Clears the value of `updateMessage`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMessage() {_uniqueStorage()._updateMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct IncomingMessageDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var dateServerSent: UInt64 {
      get {return _dateServerSent ?? 0}
      set {_dateServerSent = newValue}
    }
    /// Returns true if `dateServerSent` has been explicitly set.
    var hasDateServerSent: Bool {return self._dateServerSent != nil}
    /// Clears the value of `dateServerSent`. Subsequent reads from it will return its default value.
    mutating func clearDateServerSent() {self._dateServerSent = nil}

    /// @required
    var read: Bool {
      get {return _read ?? false}
      set {_read = newValue}
    }
    /// Returns true if `read` has been explicitly set.
    var hasRead: Bool {return self._read != nil}
    /// Clears the value of `read`. Subsequent reads from it will return its default value.
    mutating func clearRead() {self._read = nil}

    /// @required
    var sealedSender: Bool {
      get {return _sealedSender ?? false}
      set {_sealedSender = newValue}
    }
    /// Returns true if `sealedSender` has been explicitly set.
    var hasSealedSender: Bool {return self._sealedSender != nil}
    /// Clears the value of `sealedSender`. Subsequent reads from it will return its default value.
    mutating func clearSealedSender() {self._sealedSender = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _dateServerSent: UInt64? = nil
    fileprivate var _read: Bool? = nil
    fileprivate var _sealedSender: Bool? = nil
  }

  struct OutgoingMessageDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sendStatus: [BackupProtos_SendStatus] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_SendStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var recipientID: UInt64 {
    get {return _recipientID ?? 0}
    set {_recipientID = newValue}
  }
  /// Returns true if `recipientID` has been explicitly set.
  var hasRecipientID: Bool {return self._recipientID != nil}
  /// Clears the value of `recipientID`. Subsequent reads from it will return its default value.
  mutating func clearRecipientID() {self._recipientID = nil}

  var deliveryStatus: BackupProtos_SendStatus.Status {
    get {return _deliveryStatus ?? .failed}
    set {_deliveryStatus = newValue}
  }
  /// Returns true if `deliveryStatus` has been explicitly set.
  var hasDeliveryStatus: Bool {return self._deliveryStatus != nil}
  /// Clears the value of `deliveryStatus`. Subsequent reads from it will return its default value.
  mutating func clearDeliveryStatus() {self._deliveryStatus = nil}

  /// @required
  var networkFailure: Bool {
    get {return _networkFailure ?? false}
    set {_networkFailure = newValue}
  }
  /// Returns true if `networkFailure` has been explicitly set.
  var hasNetworkFailure: Bool {return self._networkFailure != nil}
  /// Clears the value of `networkFailure`. Subsequent reads from it will return its default value.
  mutating func clearNetworkFailure() {self._networkFailure = nil}

  /// @required
  var identityKeyMismatch: Bool {
    get {return _identityKeyMismatch ?? false}
    set {_identityKeyMismatch = newValue}
  }
  /// Returns true if `identityKeyMismatch` has been explicitly set.
  var hasIdentityKeyMismatch: Bool {return self._identityKeyMismatch != nil}
  /// Clears the value of `identityKeyMismatch`. Subsequent reads from it will return its default value.
  mutating func clearIdentityKeyMismatch() {self._identityKeyMismatch = nil}

  /// @required
  var sealedSender: Bool {
    get {return _sealedSender ?? false}
    set {_sealedSender = newValue}
  }
  /// Returns true if `sealedSender` has been explicitly set.
  var hasSealedSender: Bool {return self._sealedSender != nil}
  /// Clears the value of `sealedSender`. Subsequent reads from it will return its default value.
  mutating func clearSealedSender() {self._sealedSender = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case failed // = 0
    case pending // = 1
    case sent // = 2
    case delivered // = 3
    case read // = 4
    case viewed // = 5

    /// e.g. user in group was blocked, so we skipped sending to them
    case skipped // = 6

    init() {
      self = .failed
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .failed
      case 1: self = .pending
      case 2: self = .sent
      case 3: self = .delivered
      case 4: self = .read
      case 5: self = .viewed
      case 6: self = .skipped
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .failed: return 0
      case .pending: return 1
      case .sent: return 2
      case .delivered: return 3
      case .read: return 4
      case .viewed: return 5
      case .skipped: return 6
      }
    }

  }

  init() {}

  fileprivate var _recipientID: UInt64? = nil
  fileprivate var _deliveryStatus: BackupProtos_SendStatus.Status? = nil
  fileprivate var _networkFailure: Bool? = nil
  fileprivate var _identityKeyMismatch: Bool? = nil
  fileprivate var _sealedSender: Bool? = nil
  fileprivate var _timestamp: UInt64? = nil
}

#if swift(>=4.2)

extension BackupProtos_SendStatus.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Text {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var body: String {
    get {return _body ?? String()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  var bodyRanges: [BackupProtos_BodyRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _body: String? = nil
}

struct BackupProtos_StandardMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quote: BackupProtos_Quote {
    get {return _storage._quote ?? BackupProtos_Quote()}
    set {_uniqueStorage()._quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return _storage._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {_uniqueStorage()._quote = nil}

  var text: BackupProtos_Text {
    get {return _storage._text ?? BackupProtos_Text()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {_uniqueStorage()._text = nil}

  var attachments: [BackupProtos_AttachmentPointer] {
    get {return _storage._attachments}
    set {_uniqueStorage()._attachments = newValue}
  }

  var linkPreview: BackupProtos_LinkPreview {
    get {return _storage._linkPreview ?? BackupProtos_LinkPreview()}
    set {_uniqueStorage()._linkPreview = newValue}
  }
  /// Returns true if `linkPreview` has been explicitly set.
  var hasLinkPreview: Bool {return _storage._linkPreview != nil}
  /// Clears the value of `linkPreview`. Subsequent reads from it will return its default value.
  mutating func clearLinkPreview() {_uniqueStorage()._linkPreview = nil}

  var longText: BackupProtos_AttachmentPointer {
    get {return _storage._longText ?? BackupProtos_AttachmentPointer()}
    set {_uniqueStorage()._longText = newValue}
  }
  /// Returns true if `longText` has been explicitly set.
  var hasLongText: Bool {return _storage._longText != nil}
  /// Clears the value of `longText`. Subsequent reads from it will return its default value.
  mutating func clearLongText() {_uniqueStorage()._longText = nil}

  var reactions: [BackupProtos_Reaction] {
    get {return _storage._reactions}
    set {_uniqueStorage()._reactions = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_ContactMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contact: [BackupProtos_ContactAttachment] = []

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_ContactAttachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: BackupProtos_ContactAttachment.Name {
    get {return _name ?? BackupProtos_ContactAttachment.Name()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var number: [BackupProtos_ContactAttachment.Phone] = []

  var email: [BackupProtos_ContactAttachment.Email] = []

  var address: [BackupProtos_ContactAttachment.PostalAddress] = []

  var avatar: BackupProtos_ContactAttachment.Avatar {
    get {return _avatar ?? BackupProtos_ContactAttachment.Avatar()}
    set {_avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  var hasAvatar: Bool {return self._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  mutating func clearAvatar() {self._avatar = nil}

  var organization: String {
    get {return _organization ?? String()}
    set {_organization = newValue}
  }
  /// Returns true if `organization` has been explicitly set.
  var hasOrganization: Bool {return self._organization != nil}
  /// Clears the value of `organization`. Subsequent reads from it will return its default value.
  mutating func clearOrganization() {self._organization = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Name {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var givenName: String {
      get {return _givenName ?? String()}
      set {_givenName = newValue}
    }
    /// Returns true if `givenName` has been explicitly set.
    var hasGivenName: Bool {return self._givenName != nil}
    /// Clears the value of `givenName`. Subsequent reads from it will return its default value.
    mutating func clearGivenName() {self._givenName = nil}

    var familyName: String {
      get {return _familyName ?? String()}
      set {_familyName = newValue}
    }
    /// Returns true if `familyName` has been explicitly set.
    var hasFamilyName: Bool {return self._familyName != nil}
    /// Clears the value of `familyName`. Subsequent reads from it will return its default value.
    mutating func clearFamilyName() {self._familyName = nil}

    var prefix: String {
      get {return _prefix ?? String()}
      set {_prefix = newValue}
    }
    /// Returns true if `prefix` has been explicitly set.
    var hasPrefix: Bool {return self._prefix != nil}
    /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
    mutating func clearPrefix() {self._prefix = nil}

    var suffix: String {
      get {return _suffix ?? String()}
      set {_suffix = newValue}
    }
    /// Returns true if `suffix` has been explicitly set.
    var hasSuffix: Bool {return self._suffix != nil}
    /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
    mutating func clearSuffix() {self._suffix = nil}

    var middleName: String {
      get {return _middleName ?? String()}
      set {_middleName = newValue}
    }
    /// Returns true if `middleName` has been explicitly set.
    var hasMiddleName: Bool {return self._middleName != nil}
    /// Clears the value of `middleName`. Subsequent reads from it will return its default value.
    mutating func clearMiddleName() {self._middleName = nil}

    var displayName: String {
      get {return _displayName ?? String()}
      set {_displayName = newValue}
    }
    /// Returns true if `displayName` has been explicitly set.
    var hasDisplayName: Bool {return self._displayName != nil}
    /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
    mutating func clearDisplayName() {self._displayName = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _givenName: String? = nil
    fileprivate var _familyName: String? = nil
    fileprivate var _prefix: String? = nil
    fileprivate var _suffix: String? = nil
    fileprivate var _middleName: String? = nil
    fileprivate var _displayName: String? = nil
  }

  struct Phone {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var type: BackupProtos_ContactAttachment.Phone.TypeEnum {
      get {return _type ?? .home}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var label: String {
      get {return _label ?? String()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    mutating func clearLabel() {self._label = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case home // = 0
      case mobile // = 1
      case work // = 2
      case custom // = 3

      init() {
        self = .home
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .home
        case 1: self = .mobile
        case 2: self = .work
        case 3: self = .custom
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .home: return 0
        case .mobile: return 1
        case .work: return 2
        case .custom: return 3
        }
      }

    }

    init() {}

    fileprivate var _value: String? = nil
    fileprivate var _type: BackupProtos_ContactAttachment.Phone.TypeEnum? = nil
    fileprivate var _label: String? = nil
  }

  struct Email {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var type: BackupProtos_ContactAttachment.Email.TypeEnum {
      get {return _type ?? .home}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var label: String {
      get {return _label ?? String()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    mutating func clearLabel() {self._label = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case home // = 0
      case mobile // = 1
      case work // = 2
      case custom // = 3

      init() {
        self = .home
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .home
        case 1: self = .mobile
        case 2: self = .work
        case 3: self = .custom
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .home: return 0
        case .mobile: return 1
        case .work: return 2
        case .custom: return 3
        }
      }

    }

    init() {}

    fileprivate var _value: String? = nil
    fileprivate var _type: BackupProtos_ContactAttachment.Email.TypeEnum? = nil
    fileprivate var _label: String? = nil
  }

  struct PostalAddress {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: BackupProtos_ContactAttachment.PostalAddress.TypeEnum {
      get {return _type ?? .home}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var label: String {
      get {return _label ?? String()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    mutating func clearLabel() {self._label = nil}

    var street: String {
      get {return _street ?? String()}
      set {_street = newValue}
    }
    /// Returns true if `street` has been explicitly set.
    var hasStreet: Bool {return self._street != nil}
    /// Clears the value of `street`. Subsequent reads from it will return its default value.
    mutating func clearStreet() {self._street = nil}

    var pobox: String {
      get {return _pobox ?? String()}
      set {_pobox = newValue}
    }
    /// Returns true if `pobox` has been explicitly set.
    var hasPobox: Bool {return self._pobox != nil}
    /// Clears the value of `pobox`. Subsequent reads from it will return its default value.
    mutating func clearPobox() {self._pobox = nil}

    var neighborhood: String {
      get {return _neighborhood ?? String()}
      set {_neighborhood = newValue}
    }
    /// Returns true if `neighborhood` has been explicitly set.
    var hasNeighborhood: Bool {return self._neighborhood != nil}
    /// Clears the value of `neighborhood`. Subsequent reads from it will return its default value.
    mutating func clearNeighborhood() {self._neighborhood = nil}

    var city: String {
      get {return _city ?? String()}
      set {_city = newValue}
    }
    /// Returns true if `city` has been explicitly set.
    var hasCity: Bool {return self._city != nil}
    /// Clears the value of `city`. Subsequent reads from it will return its default value.
    mutating func clearCity() {self._city = nil}

    var region: String {
      get {return _region ?? String()}
      set {_region = newValue}
    }
    /// Returns true if `region` has been explicitly set.
    var hasRegion: Bool {return self._region != nil}
    /// Clears the value of `region`. Subsequent reads from it will return its default value.
    mutating func clearRegion() {self._region = nil}

    var postcode: String {
      get {return _postcode ?? String()}
      set {_postcode = newValue}
    }
    /// Returns true if `postcode` has been explicitly set.
    var hasPostcode: Bool {return self._postcode != nil}
    /// Clears the value of `postcode`. Subsequent reads from it will return its default value.
    mutating func clearPostcode() {self._postcode = nil}

    var country: String {
      get {return _country ?? String()}
      set {_country = newValue}
    }
    /// Returns true if `country` has been explicitly set.
    var hasCountry: Bool {return self._country != nil}
    /// Clears the value of `country`. Subsequent reads from it will return its default value.
    mutating func clearCountry() {self._country = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case home // = 0
      case work // = 1
      case custom // = 2

      init() {
        self = .home
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .home
        case 1: self = .work
        case 2: self = .custom
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .home: return 0
        case .work: return 1
        case .custom: return 2
        }
      }

    }

    init() {}

    fileprivate var _type: BackupProtos_ContactAttachment.PostalAddress.TypeEnum? = nil
    fileprivate var _label: String? = nil
    fileprivate var _street: String? = nil
    fileprivate var _pobox: String? = nil
    fileprivate var _neighborhood: String? = nil
    fileprivate var _city: String? = nil
    fileprivate var _region: String? = nil
    fileprivate var _postcode: String? = nil
    fileprivate var _country: String? = nil
  }

  struct Avatar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var avatar: BackupProtos_AttachmentPointer {
      get {return _storage._avatar ?? BackupProtos_AttachmentPointer()}
      set {_uniqueStorage()._avatar = newValue}
    }
    /// Returns true if `avatar` has been explicitly set.
    var hasAvatar: Bool {return _storage._avatar != nil}
    /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
    mutating func clearAvatar() {_uniqueStorage()._avatar = nil}

    var isProfile: Bool {
      get {return _storage._isProfile ?? false}
      set {_uniqueStorage()._isProfile = newValue}
    }
    /// Returns true if `isProfile` has been explicitly set.
    var hasIsProfile: Bool {return _storage._isProfile != nil}
    /// Clears the value of `isProfile`. Subsequent reads from it will return its default value.
    mutating func clearIsProfile() {_uniqueStorage()._isProfile = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _name: BackupProtos_ContactAttachment.Name? = nil
  fileprivate var _avatar: BackupProtos_ContactAttachment.Avatar? = nil
  fileprivate var _organization: String? = nil
}

#if swift(>=4.2)

extension BackupProtos_ContactAttachment.Phone.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_ContactAttachment.Email.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension BackupProtos_ContactAttachment.PostalAddress.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_DocumentMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var text: BackupProtos_Text {
    get {return _storage._text ?? BackupProtos_Text()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {_uniqueStorage()._text = nil}

  /// @required
  var document: BackupProtos_AttachmentPointer {
    get {return _storage._document ?? BackupProtos_AttachmentPointer()}
    set {_uniqueStorage()._document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  var hasDocument: Bool {return _storage._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  mutating func clearDocument() {_uniqueStorage()._document = nil}

  var reactions: [BackupProtos_Reaction] {
    get {return _storage._reactions}
    set {_uniqueStorage()._reactions = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_VoiceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quote: BackupProtos_Quote {
    get {return _storage._quote ?? BackupProtos_Quote()}
    set {_uniqueStorage()._quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return _storage._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {_uniqueStorage()._quote = nil}

  /// @required
  var audio: BackupProtos_AttachmentPointer {
    get {return _storage._audio ?? BackupProtos_AttachmentPointer()}
    set {_uniqueStorage()._audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  var hasAudio: Bool {return _storage._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  mutating func clearAudio() {_uniqueStorage()._audio = nil}

  var reactions: [BackupProtos_Reaction] {
    get {return _storage._reactions}
    set {_uniqueStorage()._reactions = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_StickerMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var sticker: BackupProtos_Sticker {
    get {return _sticker ?? BackupProtos_Sticker()}
    set {_sticker = newValue}
  }
  /// Returns true if `sticker` has been explicitly set.
  var hasSticker: Bool {return self._sticker != nil}
  /// Clears the value of `sticker`. Subsequent reads from it will return its default value.
  mutating func clearSticker() {self._sticker = nil}

  var reactions: [BackupProtos_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sticker: BackupProtos_Sticker? = nil
}

/// Tombstone for remote delete
struct BackupProtos_RemoteDeletedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BackupProtos_ScheduledMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var message: BackupProtos_ChatItem {
    get {return _message ?? BackupProtos_ChatItem()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// @required
  var scheduledTime: UInt64 {
    get {return _scheduledTime ?? 0}
    set {_scheduledTime = newValue}
  }
  /// Returns true if `scheduledTime` has been explicitly set.
  var hasScheduledTime: Bool {return self._scheduledTime != nil}
  /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
  mutating func clearScheduledTime() {self._scheduledTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: BackupProtos_ChatItem? = nil
  fileprivate var _scheduledTime: UInt64? = nil
}

struct BackupProtos_Sticker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packID: Data {
    get {return _storage._packID ?? Data()}
    set {_uniqueStorage()._packID = newValue}
  }
  /// Returns true if `packID` has been explicitly set.
  var hasPackID: Bool {return _storage._packID != nil}
  /// Clears the value of `packID`. Subsequent reads from it will return its default value.
  mutating func clearPackID() {_uniqueStorage()._packID = nil}

  var packKey: Data {
    get {return _storage._packKey ?? Data()}
    set {_uniqueStorage()._packKey = newValue}
  }
  /// Returns true if `packKey` has been explicitly set.
  var hasPackKey: Bool {return _storage._packKey != nil}
  /// Clears the value of `packKey`. Subsequent reads from it will return its default value.
  mutating func clearPackKey() {_uniqueStorage()._packKey = nil}

  var stickerID: UInt32 {
    get {return _storage._stickerID ?? 0}
    set {_uniqueStorage()._stickerID = newValue}
  }
  /// Returns true if `stickerID` has been explicitly set.
  var hasStickerID: Bool {return _storage._stickerID != nil}
  /// Clears the value of `stickerID`. Subsequent reads from it will return its default value.
  mutating func clearStickerID() {_uniqueStorage()._stickerID = nil}

  var data: BackupProtos_AttachmentPointer {
    get {return _storage._data ?? BackupProtos_AttachmentPointer()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  var emoji: String {
    get {return _storage._emoji ?? String()}
    set {_uniqueStorage()._emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  var hasEmoji: Bool {return _storage._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  mutating func clearEmoji() {_uniqueStorage()._emoji = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_LinkPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String {
    get {return _storage._url ?? String()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return _storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {_uniqueStorage()._url = nil}

  var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  var image: BackupProtos_AttachmentPointer {
    get {return _storage._image ?? BackupProtos_AttachmentPointer()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  var descriptionText: String {
    get {return _storage._descriptionText ?? String()}
    set {_uniqueStorage()._descriptionText = newValue}
  }
  /// Returns true if `descriptionText` has been explicitly set.
  var hasDescriptionText: Bool {return _storage._descriptionText != nil}
  /// Clears the value of `descriptionText`. Subsequent reads from it will return its default value.
  mutating func clearDescriptionText() {_uniqueStorage()._descriptionText = nil}

  var date: UInt64 {
    get {return _storage._date ?? 0}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {_uniqueStorage()._date = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct BackupProtos_AttachmentPointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof attachmentIdentifier {
  var cdnID: UInt64 {
    get {return _cdnID ?? 0}
    set {_cdnID = newValue}
  }
  /// Returns true if `cdnID` has been explicitly set.
  var hasCdnID: Bool {return self._cdnID != nil}
  /// Clears the value of `cdnID`. Subsequent reads from it will return its default value.
  mutating func clearCdnID() {self._cdnID = nil}

  /// }
  var cdnKey: String {
    get {return _cdnKey ?? String()}
    set {_cdnKey = newValue}
  }
  /// Returns true if `cdnKey` has been explicitly set.
  var hasCdnKey: Bool {return self._cdnKey != nil}
  /// Clears the value of `cdnKey`. Subsequent reads from it will return its default value.
  mutating func clearCdnKey() {self._cdnKey = nil}

  var contentType: String {
    get {return _contentType ?? String()}
    set {_contentType = newValue}
  }
  /// Returns true if `contentType` has been explicitly set.
  var hasContentType: Bool {return self._contentType != nil}
  /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
  mutating func clearContentType() {self._contentType = nil}

  var key: Data {
    get {return _key ?? Data()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var size: UInt32 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var digest: Data {
    get {return _digest ?? Data()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  mutating func clearDigest() {self._digest = nil}

  var incrementalMac: Data {
    get {return _incrementalMac ?? Data()}
    set {_incrementalMac = newValue}
  }
  /// Returns true if `incrementalMac` has been explicitly set.
  var hasIncrementalMac: Bool {return self._incrementalMac != nil}
  /// Clears the value of `incrementalMac`. Subsequent reads from it will return its default value.
  mutating func clearIncrementalMac() {self._incrementalMac = nil}

  var incrementalMacChunkSize: Data {
    get {return _incrementalMacChunkSize ?? Data()}
    set {_incrementalMacChunkSize = newValue}
  }
  /// Returns true if `incrementalMacChunkSize` has been explicitly set.
  var hasIncrementalMacChunkSize: Bool {return self._incrementalMacChunkSize != nil}
  /// Clears the value of `incrementalMacChunkSize`. Subsequent reads from it will return its default value.
  mutating func clearIncrementalMacChunkSize() {self._incrementalMacChunkSize = nil}

  var fileName: String {
    get {return _fileName ?? String()}
    set {_fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return self._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {self._fileName = nil}

  var flags: UInt32 {
    get {return _flags ?? 0}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {self._flags = nil}

  var width: UInt32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var height: UInt32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var caption: String {
    get {return _caption ?? String()}
    set {_caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  var hasCaption: Bool {return self._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  mutating func clearCaption() {self._caption = nil}

  var blurHash: String {
    get {return _blurHash ?? String()}
    set {_blurHash = newValue}
  }
  /// Returns true if `blurHash` has been explicitly set.
  var hasBlurHash: Bool {return self._blurHash != nil}
  /// Clears the value of `blurHash`. Subsequent reads from it will return its default value.
  mutating func clearBlurHash() {self._blurHash = nil}

  var uploadTimestamp: UInt64 {
    get {return _uploadTimestamp ?? 0}
    set {_uploadTimestamp = newValue}
  }
  /// Returns true if `uploadTimestamp` has been explicitly set.
  var hasUploadTimestamp: Bool {return self._uploadTimestamp != nil}
  /// Clears the value of `uploadTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearUploadTimestamp() {self._uploadTimestamp = nil}

  var cdnNumber: UInt32 {
    get {return _cdnNumber ?? 0}
    set {_cdnNumber = newValue}
  }
  /// Returns true if `cdnNumber` has been explicitly set.
  var hasCdnNumber: Bool {return self._cdnNumber != nil}
  /// Clears the value of `cdnNumber`. Subsequent reads from it will return its default value.
  mutating func clearCdnNumber() {self._cdnNumber = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case voiceMessage // = 0
    case borderless // = 1
    case gif // = 2

    init() {
      self = .voiceMessage
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .voiceMessage
      case 1: self = .borderless
      case 2: self = .gif
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .voiceMessage: return 0
      case .borderless: return 1
      case .gif: return 2
      }
    }

  }

  init() {}

  fileprivate var _cdnID: UInt64? = nil
  fileprivate var _cdnKey: String? = nil
  fileprivate var _contentType: String? = nil
  fileprivate var _key: Data? = nil
  fileprivate var _size: UInt32? = nil
  fileprivate var _digest: Data? = nil
  fileprivate var _incrementalMac: Data? = nil
  fileprivate var _incrementalMacChunkSize: Data? = nil
  fileprivate var _fileName: String? = nil
  fileprivate var _flags: UInt32? = nil
  fileprivate var _width: UInt32? = nil
  fileprivate var _height: UInt32? = nil
  fileprivate var _caption: String? = nil
  fileprivate var _blurHash: String? = nil
  fileprivate var _uploadTimestamp: UInt64? = nil
  fileprivate var _cdnNumber: UInt32? = nil
}

#if swift(>=4.2)

extension BackupProtos_AttachmentPointer.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Quote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var authorID: UInt64 {
    get {return _authorID ?? 0}
    set {_authorID = newValue}
  }
  /// Returns true if `authorID` has been explicitly set.
  var hasAuthorID: Bool {return self._authorID != nil}
  /// Clears the value of `authorID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorID() {self._authorID = nil}

  var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var attachments: [BackupProtos_Quote.QuotedAttachment] = []

  var bodyRanges: [BackupProtos_BodyRange] = []

  var type: BackupProtos_Quote.TypeEnum {
    get {return _type ?? .normal}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case normal // = 0
    case giftbadge // = 1

    init() {
      self = .normal
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .giftbadge
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .normal: return 0
      case .giftbadge: return 1
      }
    }

  }

  struct QuotedAttachment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var contentType: String {
      get {return _storage._contentType ?? String()}
      set {_uniqueStorage()._contentType = newValue}
    }
    /// Returns true if `contentType` has been explicitly set.
    var hasContentType: Bool {return _storage._contentType != nil}
    /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
    mutating func clearContentType() {_uniqueStorage()._contentType = nil}

    var fileName: String {
      get {return _storage._fileName ?? String()}
      set {_uniqueStorage()._fileName = newValue}
    }
    /// Returns true if `fileName` has been explicitly set.
    var hasFileName: Bool {return _storage._fileName != nil}
    /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
    mutating func clearFileName() {_uniqueStorage()._fileName = nil}

    var thumbnail: BackupProtos_AttachmentPointer {
      get {return _storage._thumbnail ?? BackupProtos_AttachmentPointer()}
      set {_uniqueStorage()._thumbnail = newValue}
    }
    /// Returns true if `thumbnail` has been explicitly set.
    var hasThumbnail: Bool {return _storage._thumbnail != nil}
    /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
    mutating func clearThumbnail() {_uniqueStorage()._thumbnail = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _id: UInt64? = nil
  fileprivate var _authorID: UInt64? = nil
  fileprivate var _text: String? = nil
  fileprivate var _type: BackupProtos_Quote.TypeEnum? = nil
}

#if swift(>=4.2)

extension BackupProtos_Quote.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_BodyRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: UInt32 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var length: UInt32 {
    get {return _length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  var hasLength: Bool {return self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  mutating func clearLength() {self._length = nil}

  /// oneof associatedValue {
  var mentionAci: String {
    get {return _mentionAci ?? String()}
    set {_mentionAci = newValue}
  }
  /// Returns true if `mentionAci` has been explicitly set.
  var hasMentionAci: Bool {return self._mentionAci != nil}
  /// Clears the value of `mentionAci`. Subsequent reads from it will return its default value.
  mutating func clearMentionAci() {self._mentionAci = nil}

  /// }
  var style: BackupProtos_BodyRange.Style {
    get {return _style ?? .none}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Style: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case bold // = 1
    case italic // = 2
    case spoiler // = 3
    case strikethrough // = 4
    case monospace // = 5

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .bold
      case 2: self = .italic
      case 3: self = .spoiler
      case 4: self = .strikethrough
      case 5: self = .monospace
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .bold: return 1
      case .italic: return 2
      case .spoiler: return 3
      case .strikethrough: return 4
      case .monospace: return 5
      }
    }

  }

  init() {}

  fileprivate var _start: UInt32? = nil
  fileprivate var _length: UInt32? = nil
  fileprivate var _mentionAci: String? = nil
  fileprivate var _style: BackupProtos_BodyRange.Style? = nil
}

#if swift(>=4.2)

extension BackupProtos_BodyRange.Style: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_Reaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  mutating func clearEmoji() {self._emoji = nil}

  /// @required
  var authorID: UInt64 {
    get {return _authorID ?? 0}
    set {_authorID = newValue}
  }
  /// Returns true if `authorID` has been explicitly set.
  var hasAuthorID: Bool {return self._authorID != nil}
  /// Clears the value of `authorID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorID() {self._authorID = nil}

  /// @required
  var sentTimestamp: UInt64 {
    get {return _sentTimestamp ?? 0}
    set {_sentTimestamp = newValue}
  }
  /// Returns true if `sentTimestamp` has been explicitly set.
  var hasSentTimestamp: Bool {return self._sentTimestamp != nil}
  /// Clears the value of `sentTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearSentTimestamp() {self._sentTimestamp = nil}

  /// @required
  var receivedTimestamp: UInt64 {
    get {return _receivedTimestamp ?? 0}
    set {_receivedTimestamp = newValue}
  }
  /// Returns true if `receivedTimestamp` has been explicitly set.
  var hasReceivedTimestamp: Bool {return self._receivedTimestamp != nil}
  /// Clears the value of `receivedTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearReceivedTimestamp() {self._receivedTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _emoji: String? = nil
  fileprivate var _authorID: UInt64? = nil
  fileprivate var _sentTimestamp: UInt64? = nil
  fileprivate var _receivedTimestamp: UInt64? = nil
}

struct BackupProtos_UpdateMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof update {
  var simpleUpdate: BackupProtos_SimpleUpdate {
    get {return _simpleUpdate ?? BackupProtos_SimpleUpdate()}
    set {_simpleUpdate = newValue}
  }
  /// Returns true if `simpleUpdate` has been explicitly set.
  var hasSimpleUpdate: Bool {return self._simpleUpdate != nil}
  /// Clears the value of `simpleUpdate`. Subsequent reads from it will return its default value.
  mutating func clearSimpleUpdate() {self._simpleUpdate = nil}

  var groupDescription: BackupProtos_GroupDescriptionUpdate {
    get {return _groupDescription ?? BackupProtos_GroupDescriptionUpdate()}
    set {_groupDescription = newValue}
  }
  /// Returns true if `groupDescription` has been explicitly set.
  var hasGroupDescription: Bool {return self._groupDescription != nil}
  /// Clears the value of `groupDescription`. Subsequent reads from it will return its default value.
  mutating func clearGroupDescription() {self._groupDescription = nil}

  var expirationTimerChange: BackupProtos_ExpirationTimerChange {
    get {return _expirationTimerChange ?? BackupProtos_ExpirationTimerChange()}
    set {_expirationTimerChange = newValue}
  }
  /// Returns true if `expirationTimerChange` has been explicitly set.
  var hasExpirationTimerChange: Bool {return self._expirationTimerChange != nil}
  /// Clears the value of `expirationTimerChange`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTimerChange() {self._expirationTimerChange = nil}

  var profileChange: BackupProtos_ProfileChange {
    get {return _profileChange ?? BackupProtos_ProfileChange()}
    set {_profileChange = newValue}
  }
  /// Returns true if `profileChange` has been explicitly set.
  var hasProfileChange: Bool {return self._profileChange != nil}
  /// Clears the value of `profileChange`. Subsequent reads from it will return its default value.
  mutating func clearProfileChange() {self._profileChange = nil}

  var threadMerge: BackupProtos_ThreadMergeEvent {
    get {return _threadMerge ?? BackupProtos_ThreadMergeEvent()}
    set {_threadMerge = newValue}
  }
  /// Returns true if `threadMerge` has been explicitly set.
  var hasThreadMerge: Bool {return self._threadMerge != nil}
  /// Clears the value of `threadMerge`. Subsequent reads from it will return its default value.
  mutating func clearThreadMerge() {self._threadMerge = nil}

  var sessionSwitchover: BackupProtos_SessionSwitchoverEvent {
    get {return _sessionSwitchover ?? BackupProtos_SessionSwitchoverEvent()}
    set {_sessionSwitchover = newValue}
  }
  /// Returns true if `sessionSwitchover` has been explicitly set.
  var hasSessionSwitchover: Bool {return self._sessionSwitchover != nil}
  /// Clears the value of `sessionSwitchover`. Subsequent reads from it will return its default value.
  mutating func clearSessionSwitchover() {self._sessionSwitchover = nil}

  /// }
  var callingMessage: BackupProtos_CallingMessage {
    get {return _callingMessage ?? BackupProtos_CallingMessage()}
    set {_callingMessage = newValue}
  }
  /// Returns true if `callingMessage` has been explicitly set.
  var hasCallingMessage: Bool {return self._callingMessage != nil}
  /// Clears the value of `callingMessage`. Subsequent reads from it will return its default value.
  mutating func clearCallingMessage() {self._callingMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _simpleUpdate: BackupProtos_SimpleUpdate? = nil
  fileprivate var _groupDescription: BackupProtos_GroupDescriptionUpdate? = nil
  fileprivate var _expirationTimerChange: BackupProtos_ExpirationTimerChange? = nil
  fileprivate var _profileChange: BackupProtos_ProfileChange? = nil
  fileprivate var _threadMerge: BackupProtos_ThreadMergeEvent? = nil
  fileprivate var _sessionSwitchover: BackupProtos_SessionSwitchoverEvent? = nil
  fileprivate var _callingMessage: BackupProtos_CallingMessage? = nil
}

struct BackupProtos_CallingMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof call {
  var callID: UInt64 {
    get {return _callID ?? 0}
    set {_callID = newValue}
  }
  /// Returns true if `callID` has been explicitly set.
  var hasCallID: Bool {return self._callID != nil}
  /// Clears the value of `callID`. Subsequent reads from it will return its default value.
  mutating func clearCallID() {self._callID = nil}

  var callMessage: BackupProtos_CallMessage {
    get {return _callMessage ?? BackupProtos_CallMessage()}
    set {_callMessage = newValue}
  }
  /// Returns true if `callMessage` has been explicitly set.
  var hasCallMessage: Bool {return self._callMessage != nil}
  /// Clears the value of `callMessage`. Subsequent reads from it will return its default value.
  mutating func clearCallMessage() {self._callMessage = nil}

  /// }
  var groupCall: BackupProtos_GroupCallMessage {
    get {return _groupCall ?? BackupProtos_GroupCallMessage()}
    set {_groupCall = newValue}
  }
  /// Returns true if `groupCall` has been explicitly set.
  var hasGroupCall: Bool {return self._groupCall != nil}
  /// Clears the value of `groupCall`. Subsequent reads from it will return its default value.
  mutating func clearGroupCall() {self._groupCall = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _callID: UInt64? = nil
  fileprivate var _callMessage: BackupProtos_CallMessage? = nil
  fileprivate var _groupCall: BackupProtos_GroupCallMessage? = nil
}

struct BackupProtos_CallMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case incomingAudioCall // = 0
    case incomingVideoCall // = 1
    case outgoingAudioCall // = 2
    case outgoingVideoCall // = 3
    case missedAudioCall // = 4
    case missedVideoCall // = 5

    init() {
      self = .incomingAudioCall
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .incomingAudioCall
      case 1: self = .incomingVideoCall
      case 2: self = .outgoingAudioCall
      case 3: self = .outgoingVideoCall
      case 4: self = .missedAudioCall
      case 5: self = .missedVideoCall
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .incomingAudioCall: return 0
      case .incomingVideoCall: return 1
      case .outgoingAudioCall: return 2
      case .outgoingVideoCall: return 3
      case .missedAudioCall: return 4
      case .missedVideoCall: return 5
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension BackupProtos_CallMessage.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_GroupCallMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var startedCallUuid: Data {
    get {return _startedCallUuid ?? Data()}
    set {_startedCallUuid = newValue}
  }
  /// Returns true if `startedCallUuid` has been explicitly set.
  var hasStartedCallUuid: Bool {return self._startedCallUuid != nil}
  /// Clears the value of `startedCallUuid`. Subsequent reads from it will return its default value.
  mutating func clearStartedCallUuid() {self._startedCallUuid = nil}

  /// @required
  var startedCallTimestamp: UInt64 {
    get {return _startedCallTimestamp ?? 0}
    set {_startedCallTimestamp = newValue}
  }
  /// Returns true if `startedCallTimestamp` has been explicitly set.
  var hasStartedCallTimestamp: Bool {return self._startedCallTimestamp != nil}
  /// Clears the value of `startedCallTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearStartedCallTimestamp() {self._startedCallTimestamp = nil}

  var inCallUuids: [Data] = []

  /// @required
  var isCallFull: Bool {
    get {return _isCallFull ?? false}
    set {_isCallFull = newValue}
  }
  /// Returns true if `isCallFull` has been explicitly set.
  var hasIsCallFull: Bool {return self._isCallFull != nil}
  /// Clears the value of `isCallFull`. Subsequent reads from it will return its default value.
  mutating func clearIsCallFull() {self._isCallFull = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startedCallUuid: Data? = nil
  fileprivate var _startedCallTimestamp: UInt64? = nil
  fileprivate var _isCallFull: Bool? = nil
}

struct BackupProtos_SimpleUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case joinedSignal // = 0
    case identityUpdate // = 1
    case identityVerified // = 2

    /// marking as unverified
    case identityDefault // = 3
    case changeNumber // = 4
    case boostRequest // = 5
    case endSession // = 6
    case chatSessionRefresh // = 7
    case badDecrypt // = 8
    case paymentsActivated // = 9
    case paymentActivationRequest // = 10

    init() {
      self = .joinedSignal
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .joinedSignal
      case 1: self = .identityUpdate
      case 2: self = .identityVerified
      case 3: self = .identityDefault
      case 4: self = .changeNumber
      case 5: self = .boostRequest
      case 6: self = .endSession
      case 7: self = .chatSessionRefresh
      case 8: self = .badDecrypt
      case 9: self = .paymentsActivated
      case 10: self = .paymentActivationRequest
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .joinedSignal: return 0
      case .identityUpdate: return 1
      case .identityVerified: return 2
      case .identityDefault: return 3
      case .changeNumber: return 4
      case .boostRequest: return 5
      case .endSession: return 6
      case .chatSessionRefresh: return 7
      case .badDecrypt: return 8
      case .paymentsActivated: return 9
      case .paymentActivationRequest: return 10
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension BackupProtos_SimpleUpdate.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct BackupProtos_GroupDescriptionUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var body: String {
    get {return _body ?? String()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _body: String? = nil
}

struct BackupProtos_ExpirationTimerChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var expiresIn: UInt32 {
    get {return _expiresIn ?? 0}
    set {_expiresIn = newValue}
  }
  /// Returns true if `expiresIn` has been explicitly set.
  var hasExpiresIn: Bool {return self._expiresIn != nil}
  /// Clears the value of `expiresIn`. Subsequent reads from it will return its default value.
  mutating func clearExpiresIn() {self._expiresIn = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiresIn: UInt32? = nil
}

struct BackupProtos_ProfileChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var previousName: String {
    get {return _previousName ?? String()}
    set {_previousName = newValue}
  }
  /// Returns true if `previousName` has been explicitly set.
  var hasPreviousName: Bool {return self._previousName != nil}
  /// Clears the value of `previousName`. Subsequent reads from it will return its default value.
  mutating func clearPreviousName() {self._previousName = nil}

  /// @required
  var newName: String {
    get {return _newName ?? String()}
    set {_newName = newValue}
  }
  /// Returns true if `newName` has been explicitly set.
  var hasNewName: Bool {return self._newName != nil}
  /// Clears the value of `newName`. Subsequent reads from it will return its default value.
  mutating func clearNewName() {self._newName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _previousName: String? = nil
  fileprivate var _newName: String? = nil
}

struct BackupProtos_ThreadMergeEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var previousE164: UInt64 {
    get {return _previousE164 ?? 0}
    set {_previousE164 = newValue}
  }
  /// Returns true if `previousE164` has been explicitly set.
  var hasPreviousE164: Bool {return self._previousE164 != nil}
  /// Clears the value of `previousE164`. Subsequent reads from it will return its default value.
  mutating func clearPreviousE164() {self._previousE164 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _previousE164: UInt64? = nil
}

struct BackupProtos_SessionSwitchoverEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var e164: UInt64 {
    get {return _e164 ?? 0}
    set {_e164 = newValue}
  }
  /// Returns true if `e164` has been explicitly set.
  var hasE164: Bool {return self._e164 != nil}
  /// Clears the value of `e164`. Subsequent reads from it will return its default value.
  mutating func clearE164() {self._e164 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _e164: UInt64? = nil
}

struct BackupProtos_StickerPack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: Data {
    get {return _id ?? Data()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// @required
  var key: Data {
    get {return _key ?? Data()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// @required
  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  /// @required
  var author: String {
    get {return _author ?? String()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  mutating func clearAuthor() {self._author = nil}

  /// First one should be cover sticker.
  var stickers: [BackupProtos_StickerPackSticker] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Data? = nil
  fileprivate var _key: Data? = nil
  fileprivate var _title: String? = nil
  fileprivate var _author: String? = nil
}

struct BackupProtos_StickerPackSticker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var data: BackupProtos_AttachmentPointer {
    get {return _storage._data ?? BackupProtos_AttachmentPointer()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  /// @required
  var emoji: String {
    get {return _storage._emoji ?? String()}
    set {_uniqueStorage()._emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  var hasEmoji: Bool {return _storage._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  mutating func clearEmoji() {_uniqueStorage()._emoji = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension BackupProtos_BackupInfo: @unchecked Sendable {}
extension BackupProtos_Frame: @unchecked Sendable {}
extension BackupProtos_AccountData: @unchecked Sendable {}
extension BackupProtos_AccountData.PhoneNumberSharingMode: @unchecked Sendable {}
extension BackupProtos_AccountData.UsernameLink: @unchecked Sendable {}
extension BackupProtos_AccountData.UsernameLink.Color: @unchecked Sendable {}
extension BackupProtos_AccountData.AccountSettings: @unchecked Sendable {}
extension BackupProtos_Recipient: @unchecked Sendable {}
extension BackupProtos_Contact: @unchecked Sendable {}
extension BackupProtos_Contact.Registered: @unchecked Sendable {}
extension BackupProtos_Group: @unchecked Sendable {}
extension BackupProtos_Group.StorySendMode: @unchecked Sendable {}
extension BackupProtos_SelfRecipient: @unchecked Sendable {}
extension BackupProtos_Chat: @unchecked Sendable {}
extension BackupProtos_DistributionList: @unchecked Sendable {}
extension BackupProtos_DistributionList.PrivacyMode: @unchecked Sendable {}
extension BackupProtos_Identity: @unchecked Sendable {}
extension BackupProtos_Call: @unchecked Sendable {}
extension BackupProtos_Call.TypeEnum: @unchecked Sendable {}
extension BackupProtos_Call.Event: @unchecked Sendable {}
extension BackupProtos_ChatItem: @unchecked Sendable {}
extension BackupProtos_ChatItem.IncomingMessageDetails: @unchecked Sendable {}
extension BackupProtos_ChatItem.OutgoingMessageDetails: @unchecked Sendable {}
extension BackupProtos_SendStatus: @unchecked Sendable {}
extension BackupProtos_SendStatus.Status: @unchecked Sendable {}
extension BackupProtos_Text: @unchecked Sendable {}
extension BackupProtos_StandardMessage: @unchecked Sendable {}
extension BackupProtos_ContactMessage: @unchecked Sendable {}
extension BackupProtos_ContactAttachment: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Name: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Phone: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Phone.TypeEnum: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Email: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Email.TypeEnum: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.PostalAddress: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.PostalAddress.TypeEnum: @unchecked Sendable {}
extension BackupProtos_ContactAttachment.Avatar: @unchecked Sendable {}
extension BackupProtos_DocumentMessage: @unchecked Sendable {}
extension BackupProtos_VoiceMessage: @unchecked Sendable {}
extension BackupProtos_StickerMessage: @unchecked Sendable {}
extension BackupProtos_RemoteDeletedMessage: @unchecked Sendable {}
extension BackupProtos_ScheduledMessage: @unchecked Sendable {}
extension BackupProtos_Sticker: @unchecked Sendable {}
extension BackupProtos_LinkPreview: @unchecked Sendable {}
extension BackupProtos_AttachmentPointer: @unchecked Sendable {}
extension BackupProtos_AttachmentPointer.Flags: @unchecked Sendable {}
extension BackupProtos_Quote: @unchecked Sendable {}
extension BackupProtos_Quote.TypeEnum: @unchecked Sendable {}
extension BackupProtos_Quote.QuotedAttachment: @unchecked Sendable {}
extension BackupProtos_BodyRange: @unchecked Sendable {}
extension BackupProtos_BodyRange.Style: @unchecked Sendable {}
extension BackupProtos_Reaction: @unchecked Sendable {}
extension BackupProtos_UpdateMessage: @unchecked Sendable {}
extension BackupProtos_CallingMessage: @unchecked Sendable {}
extension BackupProtos_CallMessage: @unchecked Sendable {}
extension BackupProtos_CallMessage.TypeEnum: @unchecked Sendable {}
extension BackupProtos_GroupCallMessage: @unchecked Sendable {}
extension BackupProtos_SimpleUpdate: @unchecked Sendable {}
extension BackupProtos_SimpleUpdate.TypeEnum: @unchecked Sendable {}
extension BackupProtos_GroupDescriptionUpdate: @unchecked Sendable {}
extension BackupProtos_ExpirationTimerChange: @unchecked Sendable {}
extension BackupProtos_ProfileChange: @unchecked Sendable {}
extension BackupProtos_ThreadMergeEvent: @unchecked Sendable {}
extension BackupProtos_SessionSwitchoverEvent: @unchecked Sendable {}
extension BackupProtos_StickerPack: @unchecked Sendable {}
extension BackupProtos_StickerPackSticker: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "BackupProtos"

extension BackupProtos_BackupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BackupInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "backupTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._version) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._backupTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._backupTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_BackupInfo, rhs: BackupProtos_BackupInfo) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._backupTime != rhs._backupTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Frame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "recipient"),
    3: .same(proto: "chat"),
    4: .same(proto: "chatItem"),
    5: .same(proto: "call"),
    6: .same(proto: "stickerPack"),
  ]

  fileprivate class _StorageClass {
    var _account: BackupProtos_AccountData? = nil
    var _recipient: BackupProtos_Recipient? = nil
    var _chat: BackupProtos_Chat? = nil
    var _chatItem: BackupProtos_ChatItem? = nil
    var _call: BackupProtos_Call? = nil
    var _stickerPack: BackupProtos_StickerPack? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _recipient = source._recipient
      _chat = source._chat
      _chatItem = source._chatItem
      _call = source._call
      _stickerPack = source._stickerPack
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._account) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._recipient) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._chat) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._chatItem) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._call) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._stickerPack) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._recipient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._chat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._chatItem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._call {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._stickerPack {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Frame, rhs: BackupProtos_Frame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._recipient != rhs_storage._recipient {return false}
        if _storage._chat != rhs_storage._chat {return false}
        if _storage._chatItem != rhs_storage._chatItem {return false}
        if _storage._call != rhs_storage._call {return false}
        if _storage._stickerPack != rhs_storage._stickerPack {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AccountData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aciIdentityPublicKey"),
    2: .same(proto: "aciIdentityPrivateKey"),
    3: .same(proto: "pniIdentityPublicKey"),
    4: .same(proto: "pniIdentityPrivateKey"),
    5: .same(proto: "profileKey"),
    6: .same(proto: "username"),
    7: .same(proto: "usernameLink"),
    8: .same(proto: "givenName"),
    9: .same(proto: "familyName"),
    10: .same(proto: "avatarPath"),
    11: .same(proto: "subscriberId"),
    12: .same(proto: "subscriberCurrencyCode"),
    13: .same(proto: "subscriptionManuallyCancelled"),
    14: .same(proto: "accountSettings"),
    15: .same(proto: "aci"),
    16: .same(proto: "pni"),
    17: .same(proto: "e164"),
  ]

  fileprivate class _StorageClass {
    var _aciIdentityPublicKey: Data? = nil
    var _aciIdentityPrivateKey: Data? = nil
    var _pniIdentityPublicKey: Data? = nil
    var _pniIdentityPrivateKey: Data? = nil
    var _profileKey: Data? = nil
    var _username: String? = nil
    var _usernameLink: BackupProtos_AccountData.UsernameLink? = nil
    var _givenName: String? = nil
    var _familyName: String? = nil
    var _avatarPath: String? = nil
    var _subscriberID: Data? = nil
    var _subscriberCurrencyCode: String? = nil
    var _subscriptionManuallyCancelled: Bool? = nil
    var _accountSettings: BackupProtos_AccountData.AccountSettings? = nil
    var _aci: Data? = nil
    var _pni: Data? = nil
    var _e164: UInt64? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _aciIdentityPublicKey = source._aciIdentityPublicKey
      _aciIdentityPrivateKey = source._aciIdentityPrivateKey
      _pniIdentityPublicKey = source._pniIdentityPublicKey
      _pniIdentityPrivateKey = source._pniIdentityPrivateKey
      _profileKey = source._profileKey
      _username = source._username
      _usernameLink = source._usernameLink
      _givenName = source._givenName
      _familyName = source._familyName
      _avatarPath = source._avatarPath
      _subscriberID = source._subscriberID
      _subscriberCurrencyCode = source._subscriberCurrencyCode
      _subscriptionManuallyCancelled = source._subscriptionManuallyCancelled
      _accountSettings = source._accountSettings
      _aci = source._aci
      _pni = source._pni
      _e164 = source._e164
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._aciIdentityPublicKey) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._aciIdentityPrivateKey) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._pniIdentityPublicKey) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._pniIdentityPrivateKey) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._username) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._usernameLink) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._givenName) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._familyName) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._avatarPath) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._subscriberID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._subscriberCurrencyCode) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._subscriptionManuallyCancelled) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._accountSettings) }()
        case 15: try { try decoder.decodeSingularBytesField(value: &_storage._aci) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._pni) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._e164) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._aciIdentityPublicKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._aciIdentityPrivateKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._pniIdentityPublicKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._pniIdentityPrivateKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._profileKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._username {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._usernameLink {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._givenName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._familyName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._avatarPath {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._subscriberID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._subscriberCurrencyCode {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._subscriptionManuallyCancelled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._accountSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._aci {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._pni {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._e164 {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_AccountData, rhs: BackupProtos_AccountData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._aciIdentityPublicKey != rhs_storage._aciIdentityPublicKey {return false}
        if _storage._aciIdentityPrivateKey != rhs_storage._aciIdentityPrivateKey {return false}
        if _storage._pniIdentityPublicKey != rhs_storage._pniIdentityPublicKey {return false}
        if _storage._pniIdentityPrivateKey != rhs_storage._pniIdentityPrivateKey {return false}
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._usernameLink != rhs_storage._usernameLink {return false}
        if _storage._givenName != rhs_storage._givenName {return false}
        if _storage._familyName != rhs_storage._familyName {return false}
        if _storage._avatarPath != rhs_storage._avatarPath {return false}
        if _storage._subscriberID != rhs_storage._subscriberID {return false}
        if _storage._subscriberCurrencyCode != rhs_storage._subscriberCurrencyCode {return false}
        if _storage._subscriptionManuallyCancelled != rhs_storage._subscriptionManuallyCancelled {return false}
        if _storage._accountSettings != rhs_storage._accountSettings {return false}
        if _storage._aci != rhs_storage._aci {return false}
        if _storage._pni != rhs_storage._pni {return false}
        if _storage._e164 != rhs_storage._e164 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AccountData.PhoneNumberSharingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVERYBODY"),
    1: .same(proto: "CONTACTS_ONLY"),
    2: .same(proto: "NOBODY"),
  ]
}

extension BackupProtos_AccountData.UsernameLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_AccountData.protoMessageName + ".UsernameLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entropy"),
    2: .same(proto: "serverId"),
    3: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._entropy) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entropy {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._serverID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_AccountData.UsernameLink, rhs: BackupProtos_AccountData.UsernameLink) -> Bool {
    if lhs._entropy != rhs._entropy {return false}
    if lhs._serverID != rhs._serverID {return false}
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AccountData.UsernameLink.Color: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BLUE"),
    2: .same(proto: "WHITE"),
    3: .same(proto: "GREY"),
    4: .same(proto: "OLIVE"),
    5: .same(proto: "GREEN"),
    6: .same(proto: "ORANGE"),
    7: .same(proto: "PINK"),
    8: .same(proto: "PURPLE"),
  ]
}

extension BackupProtos_AccountData.AccountSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_AccountData.protoMessageName + ".AccountSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "noteToSelfArchived"),
    2: .same(proto: "readReceipts"),
    3: .same(proto: "sealedSenderIndicators"),
    4: .same(proto: "typingIndicators"),
    5: .same(proto: "proxiedLinkPreviews"),
    6: .same(proto: "noteToSelfMarkedUnread"),
    7: .same(proto: "linkPreviews"),
    8: .same(proto: "unlistedPhoneNumber"),
    9: .same(proto: "preferContactAvatars"),
    10: .same(proto: "universalExpireTimer"),
    11: .same(proto: "preferredReactionEmoji"),
    12: .same(proto: "displayBadgesOnProfile"),
    13: .same(proto: "keepMutedChatsArchived"),
    14: .same(proto: "myStoriesPrivacyHasBeenSet"),
    15: .same(proto: "onboardingStoryHasBeenViewed"),
    16: .same(proto: "storiesDisabled"),
    17: .same(proto: "storyViewReceiptsEnabled"),
    18: .same(proto: "onboardingStoryHasBeenRead"),
    19: .same(proto: "groupStoryEducationSheetHasBeenSet"),
    20: .same(proto: "usernameOnboardingHasBeenCompleted"),
    21: .same(proto: "phoneNumberSharingMode"),
  ]

  fileprivate class _StorageClass {
    var _noteToSelfArchived: Bool? = nil
    var _readReceipts: Bool? = nil
    var _sealedSenderIndicators: Bool? = nil
    var _typingIndicators: Bool? = nil
    var _proxiedLinkPreviews: Bool? = nil
    var _noteToSelfMarkedUnread: Bool? = nil
    var _linkPreviews: Bool? = nil
    var _unlistedPhoneNumber: Bool? = nil
    var _preferContactAvatars: Bool? = nil
    var _universalExpireTimer: UInt32? = nil
    var _preferredReactionEmoji: [String] = []
    var _displayBadgesOnProfile: Bool? = nil
    var _keepMutedChatsArchived: Bool? = nil
    var _myStoriesPrivacyHasBeenSet: Bool? = nil
    var _onboardingStoryHasBeenViewed: Bool? = nil
    var _storiesDisabled: Bool? = nil
    var _storyViewReceiptsEnabled: Bool? = nil
    var _onboardingStoryHasBeenRead: Bool? = nil
    var _groupStoryEducationSheetHasBeenSet: Bool? = nil
    var _usernameOnboardingHasBeenCompleted: Bool? = nil
    var _phoneNumberSharingMode: BackupProtos_AccountData.PhoneNumberSharingMode? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _noteToSelfArchived = source._noteToSelfArchived
      _readReceipts = source._readReceipts
      _sealedSenderIndicators = source._sealedSenderIndicators
      _typingIndicators = source._typingIndicators
      _proxiedLinkPreviews = source._proxiedLinkPreviews
      _noteToSelfMarkedUnread = source._noteToSelfMarkedUnread
      _linkPreviews = source._linkPreviews
      _unlistedPhoneNumber = source._unlistedPhoneNumber
      _preferContactAvatars = source._preferContactAvatars
      _universalExpireTimer = source._universalExpireTimer
      _preferredReactionEmoji = source._preferredReactionEmoji
      _displayBadgesOnProfile = source._displayBadgesOnProfile
      _keepMutedChatsArchived = source._keepMutedChatsArchived
      _myStoriesPrivacyHasBeenSet = source._myStoriesPrivacyHasBeenSet
      _onboardingStoryHasBeenViewed = source._onboardingStoryHasBeenViewed
      _storiesDisabled = source._storiesDisabled
      _storyViewReceiptsEnabled = source._storyViewReceiptsEnabled
      _onboardingStoryHasBeenRead = source._onboardingStoryHasBeenRead
      _groupStoryEducationSheetHasBeenSet = source._groupStoryEducationSheetHasBeenSet
      _usernameOnboardingHasBeenCompleted = source._usernameOnboardingHasBeenCompleted
      _phoneNumberSharingMode = source._phoneNumberSharingMode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._noteToSelfArchived) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._readReceipts) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._sealedSenderIndicators) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._typingIndicators) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._proxiedLinkPreviews) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._noteToSelfMarkedUnread) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._linkPreviews) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._unlistedPhoneNumber) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._preferContactAvatars) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._universalExpireTimer) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._preferredReactionEmoji) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._displayBadgesOnProfile) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._keepMutedChatsArchived) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._myStoriesPrivacyHasBeenSet) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._onboardingStoryHasBeenViewed) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._storiesDisabled) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._storyViewReceiptsEnabled) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._onboardingStoryHasBeenRead) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._groupStoryEducationSheetHasBeenSet) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._usernameOnboardingHasBeenCompleted) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._phoneNumberSharingMode) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._noteToSelfArchived {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._readReceipts {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sealedSenderIndicators {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._typingIndicators {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._proxiedLinkPreviews {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._noteToSelfMarkedUnread {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._linkPreviews {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._unlistedPhoneNumber {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._preferContactAvatars {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._universalExpireTimer {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      } }()
      if !_storage._preferredReactionEmoji.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._preferredReactionEmoji, fieldNumber: 11)
      }
      try { if let v = _storage._displayBadgesOnProfile {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._keepMutedChatsArchived {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._myStoriesPrivacyHasBeenSet {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._onboardingStoryHasBeenViewed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._storiesDisabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._storyViewReceiptsEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._onboardingStoryHasBeenRead {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._groupStoryEducationSheetHasBeenSet {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._usernameOnboardingHasBeenCompleted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._phoneNumberSharingMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_AccountData.AccountSettings, rhs: BackupProtos_AccountData.AccountSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._noteToSelfArchived != rhs_storage._noteToSelfArchived {return false}
        if _storage._readReceipts != rhs_storage._readReceipts {return false}
        if _storage._sealedSenderIndicators != rhs_storage._sealedSenderIndicators {return false}
        if _storage._typingIndicators != rhs_storage._typingIndicators {return false}
        if _storage._proxiedLinkPreviews != rhs_storage._proxiedLinkPreviews {return false}
        if _storage._noteToSelfMarkedUnread != rhs_storage._noteToSelfMarkedUnread {return false}
        if _storage._linkPreviews != rhs_storage._linkPreviews {return false}
        if _storage._unlistedPhoneNumber != rhs_storage._unlistedPhoneNumber {return false}
        if _storage._preferContactAvatars != rhs_storage._preferContactAvatars {return false}
        if _storage._universalExpireTimer != rhs_storage._universalExpireTimer {return false}
        if _storage._preferredReactionEmoji != rhs_storage._preferredReactionEmoji {return false}
        if _storage._displayBadgesOnProfile != rhs_storage._displayBadgesOnProfile {return false}
        if _storage._keepMutedChatsArchived != rhs_storage._keepMutedChatsArchived {return false}
        if _storage._myStoriesPrivacyHasBeenSet != rhs_storage._myStoriesPrivacyHasBeenSet {return false}
        if _storage._onboardingStoryHasBeenViewed != rhs_storage._onboardingStoryHasBeenViewed {return false}
        if _storage._storiesDisabled != rhs_storage._storiesDisabled {return false}
        if _storage._storyViewReceiptsEnabled != rhs_storage._storyViewReceiptsEnabled {return false}
        if _storage._onboardingStoryHasBeenRead != rhs_storage._onboardingStoryHasBeenRead {return false}
        if _storage._groupStoryEducationSheetHasBeenSet != rhs_storage._groupStoryEducationSheetHasBeenSet {return false}
        if _storage._usernameOnboardingHasBeenCompleted != rhs_storage._usernameOnboardingHasBeenCompleted {return false}
        if _storage._phoneNumberSharingMode != rhs_storage._phoneNumberSharingMode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Recipient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Recipient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "contact"),
    3: .same(proto: "group"),
    4: .same(proto: "distributionList"),
    5: .same(proto: "selfRecipient"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64? = nil
    var _contact: BackupProtos_Contact? = nil
    var _group: BackupProtos_Group? = nil
    var _distributionList: BackupProtos_DistributionList? = nil
    var _selfRecipient: BackupProtos_SelfRecipient? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _contact = source._contact
      _group = source._group
      _distributionList = source._distributionList
      _selfRecipient = source._selfRecipient
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._contact) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._distributionList) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._selfRecipient) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._contact {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._distributionList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._selfRecipient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Recipient, rhs: BackupProtos_Recipient) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._contact != rhs_storage._contact {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._distributionList != rhs_storage._distributionList {return false}
        if _storage._selfRecipient != rhs_storage._selfRecipient {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aci"),
    2: .same(proto: "pni"),
    3: .same(proto: "username"),
    4: .same(proto: "e164"),
    5: .same(proto: "blocked"),
    6: .same(proto: "hidden"),
    7: .same(proto: "registered"),
    8: .same(proto: "unregisteredTimestamp"),
    9: .same(proto: "profileKey"),
    10: .same(proto: "profileSharing"),
    11: .same(proto: "profileGivenName"),
    12: .same(proto: "profileFamilyName"),
    13: .same(proto: "profileJoinedName"),
    14: .same(proto: "hideStory"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._aci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._pni) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._e164) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._blocked) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._hidden) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._registered) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._unregisteredTimestamp) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._profileKey) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._profileSharing) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._profileGivenName) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._profileFamilyName) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self._profileJoinedName) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self._hideStory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._aci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pni {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._e164 {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._blocked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._hidden {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._registered {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._unregisteredTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._profileKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._profileSharing {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._profileGivenName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._profileFamilyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._profileJoinedName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._hideStory {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Contact, rhs: BackupProtos_Contact) -> Bool {
    if lhs._aci != rhs._aci {return false}
    if lhs._pni != rhs._pni {return false}
    if lhs._username != rhs._username {return false}
    if lhs._e164 != rhs._e164 {return false}
    if lhs._blocked != rhs._blocked {return false}
    if lhs._hidden != rhs._hidden {return false}
    if lhs._registered != rhs._registered {return false}
    if lhs._unregisteredTimestamp != rhs._unregisteredTimestamp {return false}
    if lhs._profileKey != rhs._profileKey {return false}
    if lhs._profileSharing != rhs._profileSharing {return false}
    if lhs._profileGivenName != rhs._profileGivenName {return false}
    if lhs._profileFamilyName != rhs._profileFamilyName {return false}
    if lhs._profileJoinedName != rhs._profileJoinedName {return false}
    if lhs._hideStory != rhs._hideStory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Contact.Registered: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "REGISTERED"),
    2: .same(proto: "NOT_REGISTERED"),
  ]
}

extension BackupProtos_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "masterKey"),
    2: .same(proto: "whitelisted"),
    3: .same(proto: "hideStory"),
    4: .same(proto: "storySendMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._masterKey) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._whitelisted) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._hideStory) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._storySendMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._masterKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._whitelisted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hideStory {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._storySendMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Group, rhs: BackupProtos_Group) -> Bool {
    if lhs._masterKey != rhs._masterKey {return false}
    if lhs._whitelisted != rhs._whitelisted {return false}
    if lhs._hideStory != rhs._hideStory {return false}
    if lhs._storySendMode != rhs._storySendMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Group.StorySendMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "DISABLED"),
    2: .same(proto: "ENABLED"),
  ]
}

extension BackupProtos_SelfRecipient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelfRecipient"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SelfRecipient, rhs: BackupProtos_SelfRecipient) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Chat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Chat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "recipientId"),
    3: .same(proto: "archived"),
    4: .same(proto: "pinned"),
    5: .same(proto: "expirationTimer"),
    6: .same(proto: "muteUntil"),
    7: .same(proto: "markedUnread"),
    8: .same(proto: "dontNotifyForMentionsIfMuted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._recipientID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._archived) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._pinned) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._expirationTimer) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._muteUntil) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._markedUnread) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._dontNotifyForMentionsIfMuted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._archived {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pinned {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expirationTimer {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._muteUntil {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._markedUnread {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._dontNotifyForMentionsIfMuted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Chat, rhs: BackupProtos_Chat) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._recipientID != rhs._recipientID {return false}
    if lhs._archived != rhs._archived {return false}
    if lhs._pinned != rhs._pinned {return false}
    if lhs._expirationTimer != rhs._expirationTimer {return false}
    if lhs._muteUntil != rhs._muteUntil {return false}
    if lhs._markedUnread != rhs._markedUnread {return false}
    if lhs._dontNotifyForMentionsIfMuted != rhs._dontNotifyForMentionsIfMuted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_DistributionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DistributionList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "distributionId"),
    3: .same(proto: "allowReplies"),
    4: .same(proto: "deletionTimestamp"),
    5: .same(proto: "isUnknown"),
    6: .same(proto: "privacyMode"),
    7: .same(proto: "memberRecipientIds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._distributionID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._allowReplies) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._deletionTimestamp) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._isUnknown) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._privacyMode) }()
      case 7: try { try decoder.decodeRepeatedUInt64Field(value: &self.memberRecipientIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._distributionID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._allowReplies {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._deletionTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._isUnknown {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._privacyMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    if !self.memberRecipientIds.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.memberRecipientIds, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_DistributionList, rhs: BackupProtos_DistributionList) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._distributionID != rhs._distributionID {return false}
    if lhs._allowReplies != rhs._allowReplies {return false}
    if lhs._deletionTimestamp != rhs._deletionTimestamp {return false}
    if lhs._isUnknown != rhs._isUnknown {return false}
    if lhs._privacyMode != rhs._privacyMode {return false}
    if lhs.memberRecipientIds != rhs.memberRecipientIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_DistributionList.PrivacyMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ONLY_WITH"),
    1: .same(proto: "ALL_EXCEPT"),
    2: .same(proto: "ALL"),
  ]
}

extension BackupProtos_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Identity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceId"),
    2: .same(proto: "identityKey"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "firstUse"),
    5: .same(proto: "verified"),
    6: .same(proto: "nonblockingApproval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._serviceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._identityKey) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._firstUse) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._verified) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._nonblockingApproval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identityKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._firstUse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._verified {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nonblockingApproval {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Identity, rhs: BackupProtos_Identity) -> Bool {
    if lhs._serviceID != rhs._serviceID {return false}
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._firstUse != rhs._firstUse {return false}
    if lhs._verified != rhs._verified {return false}
    if lhs._nonblockingApproval != rhs._nonblockingApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "peerRecipientId"),
    3: .same(proto: "type"),
    4: .same(proto: "outgoing"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "ringerRecipientId"),
    7: .same(proto: "event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._callID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._peerRecipientID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._outgoing) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._ringerRecipientID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._event) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._peerRecipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._outgoing {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._ringerRecipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Call, rhs: BackupProtos_Call) -> Bool {
    if lhs._callID != rhs._callID {return false}
    if lhs._peerRecipientID != rhs._peerRecipientID {return false}
    if lhs._type != rhs._type {return false}
    if lhs._outgoing != rhs._outgoing {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._ringerRecipientID != rhs._ringerRecipientID {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Call.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO_CALL"),
    1: .same(proto: "VIDEO_CALL"),
    2: .same(proto: "GROUP_CALL"),
    3: .same(proto: "AD_HOC_CALL"),
  ]
}

extension BackupProtos_Call.Event: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OUTGOING"),
    1: .same(proto: "ACCEPTED"),
    2: .same(proto: "NOT_ACCEPTED"),
    3: .same(proto: "MISSED"),
    4: .same(proto: "DELETE"),
    5: .same(proto: "GENERIC_GROUP_CALL"),
    6: .same(proto: "JOINED"),
    7: .same(proto: "RINGING"),
    8: .same(proto: "DECLINED"),
    9: .same(proto: "OUTGOING_RING"),
  ]
}

extension BackupProtos_ChatItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chatId"),
    2: .same(proto: "authorId"),
    3: .same(proto: "dateSent"),
    4: .same(proto: "dateReceived"),
    5: .same(proto: "expireStart"),
    6: .same(proto: "expiresIn"),
    7: .same(proto: "revisions"),
    8: .same(proto: "sms"),
    9: .same(proto: "incoming"),
    10: .same(proto: "outgoing"),
    11: .same(proto: "standardMessage"),
    12: .same(proto: "contactMessage"),
    13: .same(proto: "voiceMessage"),
    14: .same(proto: "stickerMessage"),
    15: .same(proto: "remoteDeletedMessage"),
    16: .same(proto: "updateMessage"),
  ]

  fileprivate class _StorageClass {
    var _chatID: UInt64? = nil
    var _authorID: UInt64? = nil
    var _dateSent: UInt64? = nil
    var _dateReceived: UInt64? = nil
    var _expireStart: UInt64? = nil
    var _expiresIn: UInt64? = nil
    var _revisions: [BackupProtos_ChatItem] = []
    var _sms: Bool? = nil
    var _incoming: BackupProtos_ChatItem.IncomingMessageDetails? = nil
    var _outgoing: BackupProtos_ChatItem.OutgoingMessageDetails? = nil
    var _standardMessage: BackupProtos_StandardMessage? = nil
    var _contactMessage: BackupProtos_ContactMessage? = nil
    var _voiceMessage: BackupProtos_VoiceMessage? = nil
    var _stickerMessage: BackupProtos_StickerMessage? = nil
    var _remoteDeletedMessage: BackupProtos_RemoteDeletedMessage? = nil
    var _updateMessage: BackupProtos_UpdateMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chatID = source._chatID
      _authorID = source._authorID
      _dateSent = source._dateSent
      _dateReceived = source._dateReceived
      _expireStart = source._expireStart
      _expiresIn = source._expiresIn
      _revisions = source._revisions
      _sms = source._sms
      _incoming = source._incoming
      _outgoing = source._outgoing
      _standardMessage = source._standardMessage
      _contactMessage = source._contactMessage
      _voiceMessage = source._voiceMessage
      _stickerMessage = source._stickerMessage
      _remoteDeletedMessage = source._remoteDeletedMessage
      _updateMessage = source._updateMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._chatID) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._authorID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._dateSent) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._dateReceived) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._expireStart) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._expiresIn) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._revisions) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._sms) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._incoming) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._outgoing) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._standardMessage) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._contactMessage) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._voiceMessage) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._stickerMessage) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._remoteDeletedMessage) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._updateMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._chatID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._authorID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dateSent {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dateReceived {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expireStart {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._expiresIn {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
      } }()
      if !_storage._revisions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._revisions, fieldNumber: 7)
      }
      try { if let v = _storage._sms {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._incoming {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._outgoing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._standardMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._contactMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._voiceMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._stickerMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._remoteDeletedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._updateMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatItem, rhs: BackupProtos_ChatItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._authorID != rhs_storage._authorID {return false}
        if _storage._dateSent != rhs_storage._dateSent {return false}
        if _storage._dateReceived != rhs_storage._dateReceived {return false}
        if _storage._expireStart != rhs_storage._expireStart {return false}
        if _storage._expiresIn != rhs_storage._expiresIn {return false}
        if _storage._revisions != rhs_storage._revisions {return false}
        if _storage._sms != rhs_storage._sms {return false}
        if _storage._incoming != rhs_storage._incoming {return false}
        if _storage._outgoing != rhs_storage._outgoing {return false}
        if _storage._standardMessage != rhs_storage._standardMessage {return false}
        if _storage._contactMessage != rhs_storage._contactMessage {return false}
        if _storage._voiceMessage != rhs_storage._voiceMessage {return false}
        if _storage._stickerMessage != rhs_storage._stickerMessage {return false}
        if _storage._remoteDeletedMessage != rhs_storage._remoteDeletedMessage {return false}
        if _storage._updateMessage != rhs_storage._updateMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ChatItem.IncomingMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ChatItem.protoMessageName + ".IncomingMessageDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dateServerSent"),
    2: .same(proto: "read"),
    3: .same(proto: "sealedSender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._dateServerSent) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._read) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._sealedSender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dateServerSent {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._read {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sealedSender {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatItem.IncomingMessageDetails, rhs: BackupProtos_ChatItem.IncomingMessageDetails) -> Bool {
    if lhs._dateServerSent != rhs._dateServerSent {return false}
    if lhs._read != rhs._read {return false}
    if lhs._sealedSender != rhs._sealedSender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ChatItem.OutgoingMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ChatItem.protoMessageName + ".OutgoingMessageDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sendStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sendStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sendStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sendStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ChatItem.OutgoingMessageDetails, rhs: BackupProtos_ChatItem.OutgoingMessageDetails) -> Bool {
    if lhs.sendStatus != rhs.sendStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SendStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipientId"),
    2: .same(proto: "deliveryStatus"),
    3: .same(proto: "networkFailure"),
    4: .same(proto: "identityKeyMismatch"),
    5: .same(proto: "sealedSender"),
    6: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._recipientID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._deliveryStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._networkFailure) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._identityKeyMismatch) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._sealedSender) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._deliveryStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._networkFailure {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._identityKeyMismatch {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._sealedSender {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SendStatus, rhs: BackupProtos_SendStatus) -> Bool {
    if lhs._recipientID != rhs._recipientID {return false}
    if lhs._deliveryStatus != rhs._deliveryStatus {return false}
    if lhs._networkFailure != rhs._networkFailure {return false}
    if lhs._identityKeyMismatch != rhs._identityKeyMismatch {return false}
    if lhs._sealedSender != rhs._sealedSender {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SendStatus.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FAILED"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "SENT"),
    3: .same(proto: "DELIVERED"),
    4: .same(proto: "READ"),
    5: .same(proto: "VIEWED"),
    6: .same(proto: "SKIPPED"),
  ]
}

extension BackupProtos_Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Text"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "bodyRanges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._body) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bodyRanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.bodyRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyRanges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Text, rhs: BackupProtos_Text) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.bodyRanges != rhs.bodyRanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StandardMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StandardMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quote"),
    2: .same(proto: "text"),
    3: .same(proto: "attachments"),
    4: .same(proto: "linkPreview"),
    5: .same(proto: "longText"),
    6: .same(proto: "reactions"),
  ]

  fileprivate class _StorageClass {
    var _quote: BackupProtos_Quote? = nil
    var _text: BackupProtos_Text? = nil
    var _attachments: [BackupProtos_AttachmentPointer] = []
    var _linkPreview: BackupProtos_LinkPreview? = nil
    var _longText: BackupProtos_AttachmentPointer? = nil
    var _reactions: [BackupProtos_Reaction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _quote = source._quote
      _text = source._text
      _attachments = source._attachments
      _linkPreview = source._linkPreview
      _longText = source._longText
      _reactions = source._reactions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._quote) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._text) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._attachments) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._linkPreview) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._longText) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._reactions) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._quote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._text {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._attachments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attachments, fieldNumber: 3)
      }
      try { if let v = _storage._linkPreview {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._longText {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._reactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._reactions, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StandardMessage, rhs: BackupProtos_StandardMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._quote != rhs_storage._quote {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._attachments != rhs_storage._attachments {return false}
        if _storage._linkPreview != rhs_storage._linkPreview {return false}
        if _storage._longText != rhs_storage._longText {return false}
        if _storage._reactions != rhs_storage._reactions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    2: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.contact) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contact.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contact, fieldNumber: 1)
    }
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactMessage, rhs: BackupProtos_ContactMessage) -> Bool {
    if lhs.contact != rhs.contact {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "number"),
    4: .same(proto: "email"),
    5: .same(proto: "address"),
    6: .same(proto: "avatar"),
    7: .same(proto: "organization"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.number) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.email) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.address) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._organization) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.number.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.number, fieldNumber: 3)
    }
    if !self.email.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.email, fieldNumber: 4)
    }
    if !self.address.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.address, fieldNumber: 5)
    }
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._organization {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment, rhs: BackupProtos_ContactAttachment) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.number != rhs.number {return false}
    if lhs.email != rhs.email {return false}
    if lhs.address != rhs.address {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs._organization != rhs._organization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Name"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "givenName"),
    2: .same(proto: "familyName"),
    3: .same(proto: "prefix"),
    4: .same(proto: "suffix"),
    5: .same(proto: "middleName"),
    6: .same(proto: "displayName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._givenName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._familyName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._prefix) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._suffix) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._middleName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._givenName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._familyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._suffix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._middleName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Name, rhs: BackupProtos_ContactAttachment.Name) -> Bool {
    if lhs._givenName != rhs._givenName {return false}
    if lhs._familyName != rhs._familyName {return false}
    if lhs._prefix != rhs._prefix {return false}
    if lhs._suffix != rhs._suffix {return false}
    if lhs._middleName != rhs._middleName {return false}
    if lhs._displayName != rhs._displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Phone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Phone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Phone, rhs: BackupProtos_ContactAttachment.Phone) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Phone.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HOME"),
    1: .same(proto: "MOBILE"),
    2: .same(proto: "WORK"),
    3: .same(proto: "CUSTOM"),
  ]
}

extension BackupProtos_ContactAttachment.Email: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Email"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Email, rhs: BackupProtos_ContactAttachment.Email) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.Email.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HOME"),
    1: .same(proto: "MOBILE"),
    2: .same(proto: "WORK"),
    3: .same(proto: "CUSTOM"),
  ]
}

extension BackupProtos_ContactAttachment.PostalAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".PostalAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "label"),
    3: .same(proto: "street"),
    4: .same(proto: "pobox"),
    5: .same(proto: "neighborhood"),
    6: .same(proto: "city"),
    7: .same(proto: "region"),
    8: .same(proto: "postcode"),
    9: .same(proto: "country"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._street) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._pobox) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._neighborhood) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._city) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._region) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._postcode) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._country) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._street {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pobox {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._neighborhood {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._city {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._region {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._postcode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._country {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.PostalAddress, rhs: BackupProtos_ContactAttachment.PostalAddress) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs._street != rhs._street {return false}
    if lhs._pobox != rhs._pobox {return false}
    if lhs._neighborhood != rhs._neighborhood {return false}
    if lhs._city != rhs._city {return false}
    if lhs._region != rhs._region {return false}
    if lhs._postcode != rhs._postcode {return false}
    if lhs._country != rhs._country {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ContactAttachment.PostalAddress.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HOME"),
    1: .same(proto: "WORK"),
    2: .same(proto: "CUSTOM"),
  ]
}

extension BackupProtos_ContactAttachment.Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_ContactAttachment.protoMessageName + ".Avatar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatar"),
    2: .same(proto: "isProfile"),
  ]

  fileprivate class _StorageClass {
    var _avatar: BackupProtos_AttachmentPointer? = nil
    var _isProfile: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _avatar = source._avatar
      _isProfile = source._isProfile
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._avatar) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._isProfile) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._avatar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._isProfile {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ContactAttachment.Avatar, rhs: BackupProtos_ContactAttachment.Avatar) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._isProfile != rhs_storage._isProfile {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_DocumentMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "document"),
    3: .same(proto: "reactions"),
  ]

  fileprivate class _StorageClass {
    var _text: BackupProtos_Text? = nil
    var _document: BackupProtos_AttachmentPointer? = nil
    var _reactions: [BackupProtos_Reaction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _text = source._text
      _document = source._document
      _reactions = source._reactions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._text) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._document) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._reactions) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._text {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._document {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._reactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._reactions, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_DocumentMessage, rhs: BackupProtos_DocumentMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._text != rhs_storage._text {return false}
        if _storage._document != rhs_storage._document {return false}
        if _storage._reactions != rhs_storage._reactions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_VoiceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VoiceMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quote"),
    2: .same(proto: "audio"),
    3: .same(proto: "reactions"),
  ]

  fileprivate class _StorageClass {
    var _quote: BackupProtos_Quote? = nil
    var _audio: BackupProtos_AttachmentPointer? = nil
    var _reactions: [BackupProtos_Reaction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _quote = source._quote
      _audio = source._audio
      _reactions = source._reactions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._quote) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._reactions) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._quote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._reactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._reactions, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_VoiceMessage, rhs: BackupProtos_VoiceMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._quote != rhs_storage._quote {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._reactions != rhs_storage._reactions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StickerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StickerMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sticker"),
    2: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sticker) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sticker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StickerMessage, rhs: BackupProtos_StickerMessage) -> Bool {
    if lhs._sticker != rhs._sticker {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_RemoteDeletedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteDeletedMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_RemoteDeletedMessage, rhs: BackupProtos_RemoteDeletedMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ScheduledMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScheduledMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "scheduledTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._scheduledTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._scheduledTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ScheduledMessage, rhs: BackupProtos_ScheduledMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs._scheduledTime != rhs._scheduledTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Sticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packId"),
    2: .same(proto: "packKey"),
    3: .same(proto: "stickerId"),
    4: .same(proto: "data"),
    5: .same(proto: "emoji"),
  ]

  fileprivate class _StorageClass {
    var _packID: Data? = nil
    var _packKey: Data? = nil
    var _stickerID: UInt32? = nil
    var _data: BackupProtos_AttachmentPointer? = nil
    var _emoji: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _packID = source._packID
      _packKey = source._packKey
      _stickerID = source._stickerID
      _data = source._data
      _emoji = source._emoji
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._packID) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._packKey) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._stickerID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._emoji) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._packID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._packKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stickerID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._emoji {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Sticker, rhs: BackupProtos_Sticker) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._packID != rhs_storage._packID {return false}
        if _storage._packKey != rhs_storage._packKey {return false}
        if _storage._stickerID != rhs_storage._stickerID {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._emoji != rhs_storage._emoji {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_LinkPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinkPreview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "image"),
    4: .same(proto: "descriptionText"),
    5: .same(proto: "date"),
  ]

  fileprivate class _StorageClass {
    var _url: String? = nil
    var _title: String? = nil
    var _image: BackupProtos_AttachmentPointer? = nil
    var _descriptionText: String? = nil
    var _date: UInt64? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _url = source._url
      _title = source._title
      _image = source._image
      _descriptionText = source._descriptionText
      _date = source._date
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._descriptionText) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._date) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._url {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._descriptionText {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._date {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_LinkPreview, rhs: BackupProtos_LinkPreview) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._url != rhs_storage._url {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._descriptionText != rhs_storage._descriptionText {return false}
        if _storage._date != rhs_storage._date {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AttachmentPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachmentPointer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cdnId"),
    2: .same(proto: "cdnKey"),
    3: .same(proto: "contentType"),
    4: .same(proto: "key"),
    5: .same(proto: "size"),
    6: .same(proto: "digest"),
    7: .same(proto: "incrementalMac"),
    8: .same(proto: "incrementalMacChunkSize"),
    9: .same(proto: "fileName"),
    10: .same(proto: "flags"),
    11: .same(proto: "width"),
    12: .same(proto: "height"),
    13: .same(proto: "caption"),
    14: .same(proto: "blurHash"),
    15: .same(proto: "uploadTimestamp"),
    16: .same(proto: "cdnNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._cdnID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._cdnKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._size) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._digest) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._incrementalMac) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._incrementalMacChunkSize) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self._width) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self._height) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self._caption) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self._blurHash) }()
      case 15: try { try decoder.decodeSingularUInt64Field(value: &self._uploadTimestamp) }()
      case 16: try { try decoder.decodeSingularUInt32Field(value: &self._cdnNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cdnID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cdnKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._digest {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._incrementalMac {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._incrementalMacChunkSize {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._width {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._caption {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._blurHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._uploadTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._cdnNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_AttachmentPointer, rhs: BackupProtos_AttachmentPointer) -> Bool {
    if lhs._cdnID != rhs._cdnID {return false}
    if lhs._cdnKey != rhs._cdnKey {return false}
    if lhs._contentType != rhs._contentType {return false}
    if lhs._key != rhs._key {return false}
    if lhs._size != rhs._size {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs._incrementalMac != rhs._incrementalMac {return false}
    if lhs._incrementalMacChunkSize != rhs._incrementalMacChunkSize {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._caption != rhs._caption {return false}
    if lhs._blurHash != rhs._blurHash {return false}
    if lhs._uploadTimestamp != rhs._uploadTimestamp {return false}
    if lhs._cdnNumber != rhs._cdnNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_AttachmentPointer.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOICE_MESSAGE"),
    1: .same(proto: "BORDERLESS"),
    2: .same(proto: "GIF"),
  ]
}

extension BackupProtos_Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Quote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "authorId"),
    3: .same(proto: "text"),
    4: .same(proto: "attachments"),
    5: .same(proto: "bodyRanges"),
    6: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._authorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.bodyRanges) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authorID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 4)
    }
    if !self.bodyRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyRanges, fieldNumber: 5)
    }
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Quote, rhs: BackupProtos_Quote) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._authorID != rhs._authorID {return false}
    if lhs._text != rhs._text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.bodyRanges != rhs.bodyRanges {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_Quote.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "GIFTBADGE"),
  ]
}

extension BackupProtos_Quote.QuotedAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BackupProtos_Quote.protoMessageName + ".QuotedAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "fileName"),
    3: .same(proto: "thumbnail"),
  ]

  fileprivate class _StorageClass {
    var _contentType: String? = nil
    var _fileName: String? = nil
    var _thumbnail: BackupProtos_AttachmentPointer? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contentType = source._contentType
      _fileName = source._fileName
      _thumbnail = source._thumbnail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._contentType) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._fileName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnail) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._contentType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._fileName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._thumbnail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Quote.QuotedAttachment, rhs: BackupProtos_Quote.QuotedAttachment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contentType != rhs_storage._contentType {return false}
        if _storage._fileName != rhs_storage._fileName {return false}
        if _storage._thumbnail != rhs_storage._thumbnail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_BodyRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BodyRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "length"),
    3: .same(proto: "mentionAci"),
    4: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._mentionAci) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._style) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mentionAci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_BodyRange, rhs: BackupProtos_BodyRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._length != rhs._length {return false}
    if lhs._mentionAci != rhs._mentionAci {return false}
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_BodyRange.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "BOLD"),
    2: .same(proto: "ITALIC"),
    3: .same(proto: "SPOILER"),
    4: .same(proto: "STRIKETHROUGH"),
    5: .same(proto: "MONOSPACE"),
  ]
}

extension BackupProtos_Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .same(proto: "authorId"),
    3: .same(proto: "sentTimestamp"),
    4: .same(proto: "receivedTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._authorID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._sentTimestamp) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._receivedTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authorID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sentTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._receivedTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_Reaction, rhs: BackupProtos_Reaction) -> Bool {
    if lhs._emoji != rhs._emoji {return false}
    if lhs._authorID != rhs._authorID {return false}
    if lhs._sentTimestamp != rhs._sentTimestamp {return false}
    if lhs._receivedTimestamp != rhs._receivedTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_UpdateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "simpleUpdate"),
    2: .same(proto: "groupDescription"),
    3: .same(proto: "expirationTimerChange"),
    4: .same(proto: "profileChange"),
    5: .same(proto: "threadMerge"),
    6: .same(proto: "sessionSwitchover"),
    7: .same(proto: "callingMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._simpleUpdate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._groupDescription) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expirationTimerChange) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._profileChange) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._threadMerge) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sessionSwitchover) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._callingMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._simpleUpdate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupDescription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._expirationTimerChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._profileChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._threadMerge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._sessionSwitchover {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._callingMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_UpdateMessage, rhs: BackupProtos_UpdateMessage) -> Bool {
    if lhs._simpleUpdate != rhs._simpleUpdate {return false}
    if lhs._groupDescription != rhs._groupDescription {return false}
    if lhs._expirationTimerChange != rhs._expirationTimerChange {return false}
    if lhs._profileChange != rhs._profileChange {return false}
    if lhs._threadMerge != rhs._threadMerge {return false}
    if lhs._sessionSwitchover != rhs._sessionSwitchover {return false}
    if lhs._callingMessage != rhs._callingMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_CallingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "callMessage"),
    3: .same(proto: "groupCall"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._callID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._callMessage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._groupCall) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._callMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupCall {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_CallingMessage, rhs: BackupProtos_CallingMessage) -> Bool {
    if lhs._callID != rhs._callID {return false}
    if lhs._callMessage != rhs._callMessage {return false}
    if lhs._groupCall != rhs._groupCall {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_CallMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_CallMessage, rhs: BackupProtos_CallMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_CallMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INCOMING_AUDIO_CALL"),
    1: .same(proto: "INCOMING_VIDEO_CALL"),
    2: .same(proto: "OUTGOING_AUDIO_CALL"),
    3: .same(proto: "OUTGOING_VIDEO_CALL"),
    4: .same(proto: "MISSED_AUDIO_CALL"),
    5: .same(proto: "MISSED_VIDEO_CALL"),
  ]
}

extension BackupProtos_GroupCallMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupCallMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startedCallUuid"),
    2: .same(proto: "startedCallTimestamp"),
    3: .same(proto: "inCallUuids"),
    4: .same(proto: "isCallFull"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._startedCallUuid) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._startedCallTimestamp) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.inCallUuids) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isCallFull) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startedCallUuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startedCallTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.inCallUuids.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.inCallUuids, fieldNumber: 3)
    }
    try { if let v = self._isCallFull {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupCallMessage, rhs: BackupProtos_GroupCallMessage) -> Bool {
    if lhs._startedCallUuid != rhs._startedCallUuid {return false}
    if lhs._startedCallTimestamp != rhs._startedCallTimestamp {return false}
    if lhs.inCallUuids != rhs.inCallUuids {return false}
    if lhs._isCallFull != rhs._isCallFull {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SimpleUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimpleUpdate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SimpleUpdate, rhs: BackupProtos_SimpleUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SimpleUpdate.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JOINED_SIGNAL"),
    1: .same(proto: "IDENTITY_UPDATE"),
    2: .same(proto: "IDENTITY_VERIFIED"),
    3: .same(proto: "IDENTITY_DEFAULT"),
    4: .same(proto: "CHANGE_NUMBER"),
    5: .same(proto: "BOOST_REQUEST"),
    6: .same(proto: "END_SESSION"),
    7: .same(proto: "CHAT_SESSION_REFRESH"),
    8: .same(proto: "BAD_DECRYPT"),
    9: .same(proto: "PAYMENTS_ACTIVATED"),
    10: .same(proto: "PAYMENT_ACTIVATION_REQUEST"),
  ]
}

extension BackupProtos_GroupDescriptionUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupDescriptionUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_GroupDescriptionUpdate, rhs: BackupProtos_GroupDescriptionUpdate) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ExpirationTimerChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpirationTimerChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiresIn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._expiresIn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expiresIn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ExpirationTimerChange, rhs: BackupProtos_ExpirationTimerChange) -> Bool {
    if lhs._expiresIn != rhs._expiresIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ProfileChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProfileChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousName"),
    2: .same(proto: "newName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._previousName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._newName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._previousName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ProfileChange, rhs: BackupProtos_ProfileChange) -> Bool {
    if lhs._previousName != rhs._previousName {return false}
    if lhs._newName != rhs._newName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_ThreadMergeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThreadMergeEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousE164"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._previousE164) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._previousE164 {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_ThreadMergeEvent, rhs: BackupProtos_ThreadMergeEvent) -> Bool {
    if lhs._previousE164 != rhs._previousE164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_SessionSwitchoverEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionSwitchoverEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "e164"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._e164) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._e164 {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_SessionSwitchoverEvent, rhs: BackupProtos_SessionSwitchoverEvent) -> Bool {
    if lhs._e164 != rhs._e164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StickerPack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StickerPack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
    3: .same(proto: "title"),
    4: .same(proto: "author"),
    5: .same(proto: "stickers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.stickers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.stickers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stickers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StickerPack, rhs: BackupProtos_StickerPack) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._key != rhs._key {return false}
    if lhs._title != rhs._title {return false}
    if lhs._author != rhs._author {return false}
    if lhs.stickers != rhs.stickers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProtos_StickerPackSticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StickerPackSticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "emoji"),
  ]

  fileprivate class _StorageClass {
    var _data: BackupProtos_AttachmentPointer? = nil
    var _emoji: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _data = source._data
      _emoji = source._emoji
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._emoji) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._emoji {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BackupProtos_StickerPackSticker, rhs: BackupProtos_StickerPackSticker) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._data != rhs_storage._data {return false}
        if _storage._emoji != rhs_storage._emoji {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
